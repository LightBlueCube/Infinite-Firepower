untyped

global function ClassicRodeo_InitPlaylistVars

#if SERVER
global function CreateClassicRodeoWeakpoint

const array<int> ELECTRIC_SMOKE_DAMAGETYPES = [ eDamageSourceId.mp_titanability_smoke,
									 			eDamageSourceId.mp_weapon_grenade_electric_smoke ]
#endif


const asset RODEO_WEAKPOINT_HITBOX_MODEL = $"models/weapons/bullets/triple_threat_projectile.mdl" // $"models/Weapons/ammoboxes/backpack_single.mdl" // this one's too big, will block many damages
const asset RODEO_GRENADE_HINT_ENT_MODEL = $"models/weapons/bullets/mgl_grenade.mdl"

void function ClassicRodeo_InitPlaylistVars()
{
	AddPrivateMatchModeSettingEnum( "#MODE_SETTING_CATEGORY_TITAN", "classic_rodeo", [ "#SETTING_DISABLED", "#SETTING_ENABLED" ], "0" )
#if SERVER
	PrecacheModel( RODEO_WEAKPOINT_HITBOX_MODEL )
#endif
}

#if SERVER
// UTILITY
entity function CreateClassicRodeoWeakpoint( entity player, entity titan )
{
	entity weakpoint = CreatePropScript( RODEO_WEAKPOINT_HITBOX_MODEL )//
	weakpoint.SetParent( titan, "RODEO_BATTERY" )
	weakpoint.SetLocalOrigin( < 0, -4, 0 > ) // < 0, 0, 0 > for ammobox
	weakpoint.SetLocalAngles( < 90, -90, 0 > )
	weakpoint.SetTakeDamageType( DAMAGE_YES )
	SetTeam( weakpoint, TEAM_UNASSIGNED )
	SetObjectCanBeMeleed( weakpoint, false )
	weakpoint.kv.solid = 6
	weakpoint.Hide()

	//entity useHintEnt = CreateRodeoGrenadeHintEntityForPlayer( player, titan )
	//thread TrackWeakPointLifeTime( weakpoint, useHintEnt )

	entity titanSoul = titan.GetTitanSoul()
	// stryder ones don't really work in the default position, so change it
	// note: stryders are way too easy to hit because of this lol so possibly fuck with it
	if ( GetSoulTitanSubClass( titanSoul ) == "stryder" )
		weakpoint.SetLocalOrigin( < 0, -2, 0 > ) // < 0, 4, -4 > for ammobox

	weakpoint.s.pilot <- player
	weakpoint.s.titanSoul <- titanSoul

	AddEntityCallback_OnDamaged( weakpoint, OnRodeoWeakpointDamaged )

	return weakpoint
}

/*entity function CreateRodeoGrenadeHintEntityForPlayer( entity player, entity titan )
{
	entity useHintEnt = CreatePropScript( RODEO_GRENADE_HINT_ENT_MODEL )
	useHintEnt.SetParent( titan, "RODEO_BATTERY" )
	useHintEnt.SetOrigin( < 0,-10,0 > )
	useHintEnt.SetTakeDamageType( DAMAGE_NO )
	SetTeam( useHintEnt, player.GetTeam() )
	SetObjectCanBeMeleed( useHintEnt, false )
	useHintEnt.kv.solid = SOLID_VPHYSICS
	useHintEnt.Hide()
	//useHintEnt.SetOwner( player ) // don't do this, this will make entity have no collision with owner, in this case which means not showing any hints

	useHintEnt.SetUsable()
	//useHintEnt.SetUsableByGroup( "friendlies pilot" )
	useHintEnt.SetUsePrompts( "按下%melee%投擲手雷", "按住%melee%投擲手雷" ) // why this not showing anything,..

	thread DestroyHintOnPressedMelee( player, useHintEnt )

	return useHintEnt
}

void function DestroyHintOnPressedMelee( entity player, entity useHintEnt )
{
	player.EndSignal( "OnDestroy" )
	useHintEnt.EndSignal( "OnDestroy" )

	while( true )
	{
		if( player.IsInputCommandHeld( IN_MELEE ) )
			useHintEnt.Destroy()
		WaitFrame()
	}
}

void function TrackWeakPointLifeTime( entity weakpoint, entity ent )
{
	ent.EndSignal( "OnDestroy" )

	weakpoint.WaitSignal( "OnDestroy" )
	ent.Destroy()
}*/

void function OnRodeoWeakpointDamaged( entity weakpoint, var damageInfo )
{
	DamageInfo_SetDamage( damageInfo, 0 ) // make sure weakpoint ent doesn't die ever
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( attacker != weakpoint.s.pilot ) // avoid things like reapers trigger following things
		return
	entity titanSoul = attacker.GetTitanSoulBeingRodeoed()
	if( !IsValid( titanSoul ) )
		return
	entity titan = titanSoul.GetTitan() // real titan
	if( !IsValid( titan ) )
		return
	float damageAmount = DamageInfo_GetDamage( damageInfo )
	if ( titanSoul != weakpoint.s.titanSoul )
		return

	// figure out damage to deal to titan
	entity attackerWeapon = DamageInfo_GetWeapon( damageInfo )
	if ( !IsValid( attackerWeapon ) )
		attackerWeapon = attacker.GetActiveWeapon()

	// most weapons in ttf2 don't have damage_rodeo, let's use it's damage_near_value_titanarmor
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	bool shouldMultiplyDamage = true
	int rodeoDamage = attackerWeapon.GetWeaponSettingInt( eWeaponVar.damage_rodeo )
	bool canNormallyDamage = attackerWeapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
	if( canNormallyDamage )
		shouldMultiplyDamage = false
	float damageScale = attackerWeapon.GetWeaponSettingFloat( eWeaponVar.critical_hit_damage_scale )

	if( IsValid( inflictor ) )
	{
		if( inflictor.IsProjectile() )
		{
			//print( "inflictor is projectile!" )
			if( inflictor.GetClassName() == "grenade" )
			{
				//print( "damaged by grenade!" )
				shouldMultiplyDamage = false
				if( "rodeoDamagedOnce" in inflictor.s ) // prevent MGL from dealing damage twice as normal( explosion will have less damage )
				{
					if( expect bool( inflictor.s.rodeoDamagedOnce ) )
						rodeoDamage = attackerWeapon.GetWeaponSettingInt( eWeaponVar.explosion_damage_heavy_armor )
				}
				inflictor.s.rodeoDamagedOnce <- true
			}
		}
		if( inflictor.GetScriptName() == "ball_lightning" ) // modified in _ball_lightning.gnut, assuming this is ballLightning
		{
			//print( "damaged by arcball!" )
			rodeoDamage = int( inflictor.e.ballLightningData.damage )
			shouldMultiplyDamage = false
		}
	}
	else if( ELECTRIC_SMOKE_DAMAGETYPES.contains( damageSourceID ) ) // hardcoded here
	{
		return // don't do additional damage to smokes
		//rodeoDamage = 300 // electric smoke grenade's damage per tick
		//shouldMultiplyDamage = false
	}
	if( shouldMultiplyDamage )
		rodeoDamage = int( rodeoDamage * damageScale * 1.5 )

	//print( rodeoDamage )
	// damage titanSoul, make sure DF_BYPASS_SHIELD	is a thing for proper behaviour
	titan.TakeDamage( rodeoDamage, attacker, attackerWeapon, { damageSourceId = eDamageSourceId.rodeo, scriptType = DamageInfo_GetCustomDamageType( damageInfo ) | DF_BYPASS_SHIELD | DF_CRITICAL } )

	// hitmarker, automatically triggered by "target.TakeDamage()"
	//attacker.NotifyDidDamage( weakpoint, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ) | DF_CRITICAL, rodeoDamage, DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
}
#endif