untyped
global function KsGUI_Init
global function SendKsGUI_Threaded

void function KsGUI_Init()
{
	AddCallback_OnClientConnected( OnClientConnected )
	RegisterSignal( "SendingNewGUI" )
}

void function SendKsGUI_Threaded( entity player, string text, vector rgb, float time, float fadeoutTime, string functionref( entity, string, string ) textChangeFunc = null, float pos = 0.3 )
{
	player.EndSignal( "OnDestroy" )
	player.Signal( "SendingNewGUI" )
	player.EndSignal( "SendingNewGUI" )

	string output
	for( int i = int( time * 10 ); i > 0; i-- )
	{
		if( textChangeFunc != null )
			output = textChangeFunc( player, text, output )
		else
			output = text

		SendHudMessage( player, output, -1, pos, int( rgb.x ), int( rgb.y ), int( rgb.z ), 255, 0, 0.2, 0.0 )
		WaitFrame()
	}
	player.s.GUIActive = false
	float fadeoutTick = fadeoutTime * 10
	vector rgbFadeout = < rgb.x / fadeoutTick, rgb.y / fadeoutTick, rgb.z / fadeoutTick >
	for( int i = int( fadeoutTick ); i > 0; i-- )
	{
		rgb = rgb - rgbFadeout

		if( textChangeFunc != null )
			output = textChangeFunc( player, text, output )
		else
			output = text

		SendHudMessage( player, output, -1, pos, int( rgb.x ), int( rgb.y ), int( rgb.z ), 255, 0, 0, float( i ) / 10 )
		WaitFrame()
	}
	player.s.GUIClose = true
}

void function OnClientConnected( entity player )
{
	player.s.KsGUIL1 <- 0
	player.s.GUIActive <- false
	player.s.GUIClose <- true
	player.s.GUIDisable <- false
	AddPlayerHeldButtonEventCallback( player, IN_OFFHAND2, KsGUI, 0 )
}

void function KsGUI( entity player )
{
	if( !KillStreakEnable() || !player.IsHuman() || player.s.usingCruiseMissile || player.s.GUIDisable )
		return

	table result = {}
	result.timeOut <- false

	OnThreadEnd(
		function() : ( player, result )
		{
			if( !IsValid( player ) || result.timeOut )
				return
			if( player.s.usingCruiseMissile || player.s.GUIDisable || !player.IsHuman() )
				return

			KsGUI_SwitchL1( player )
		}
	)

	wait 0.3
	if( player.s.usingCruiseMissile || player.s.GUIDisable || !player.IsHuman() )
		return

	if( player.s.GUIClose && PlayerHasMaxBatteryCount( player ) )
	{
		result.timeOut <- true
		return DropBattery( player )
	}
	if( !player.s.GUIActive )
		return

	result.timeOut <- true
	KsGUI_SelectL1( player )
}

const array<string> KSGUI_L1_TEXT =	[ "核武泰坦", "巡弋飞弹", "VTOL", "折叠时空武器", "丢出电池", "使用电池" ]

void function KsGUI_SwitchL1( entity player )
{
	if( player.s.GUIClose && [ 4, 5 ].contains( expect int( player.s.KsGUIL1 ) ) )
		player.s.KsGUIL1 = 0
	if( player.s.GUIActive )
	{
		if( player.s.KsGUIL1 < KSGUI_L1_TEXT.len() - 1 )
			player.s.KsGUIL1 += 1
		else
			player.s.KsGUIL1 = 0
	}

	player.s.GUIActive = true
	player.s.GUIClose = false
	EmitSoundOnEntityOnlyToPlayer( player, player, "menu_click" )
	thread SendKsGUI_Threaded( player, "", < 200, 200, 255 >, 2, 1, KsGUIL1TextChange )
}

string function KsGUIL1TextChange( entity player, string baseText, string text )
{

	array<var> skipL1Elem = []
	if( player.s.NukeTitan == 0 )
		skipL1Elem.append( 0 )
	if( player.s.CruiseMissile == 0 )
		skipL1Elem.append( 1 )
    if( !player.s.HaveVTOL )
		skipL1Elem.append( 2 )
	if( !player.s.HaveNuclearBomb )
		skipL1Elem.append( 3 )
	if( !PlayerHasMaxBatteryCount( player ) )
		skipL1Elem.append( 4 )
	if( !PlayerHasMaxBatteryCount( player ) || player.GetShieldHealth() == player.GetShieldHealthMax() )
		skipL1Elem.append( 5 )

	if( skipL1Elem.len() == KSGUI_L1_TEXT.len() )
	{
		player.s.KsGUIL1 = -1
		player.s.GUIActive = false
	}
	else if( player.s.KsGUIL1 == -1 )
		player.s.KsGUIL1 = 0

	bool onlyShowBatteryElem = false
	if( skipL1Elem.contains( 0 ) && skipL1Elem.contains( 1 ) &&/* skipL1Elem.contains( 2 ) &&*/ skipL1Elem.contains( 3 ) )
		onlyShowBatteryElem = true

	foreach( i in skipL1Elem )
	{
		if( player.s.KsGUIL1 == -1 )
			break
		if( skipL1Elem.contains( player.s.KsGUIL1 ) )
		{
			if( player.s.KsGUIL1 < KSGUI_L1_TEXT.len() - 1 )
				player.s.KsGUIL1 += 1
			else
				player.s.KsGUIL1 = 0
		}
	}


	local l1 = player.s.KsGUIL1
	string text = "短按切换 == Main Menu == 长按选中\n\n"
	bool isFristElem = true

	for( int i = 0; i < KSGUI_L1_TEXT.len(); i++ )
	{
		if( l1 == -1 )
		{
			text += "啥都木有 ┐(‘～`;)┌"
			break
		}

		if( skipL1Elem.contains( i ) )
			continue

		if( i == 4 )
		{
			isFristElem = true
			if( !onlyShowBatteryElem )
				text += "\n"
		}

		// ◆text1(03)◆ "-" ◇text2◇
		if( !isFristElem )
			text += "-"
		isFristElem = false

		//" "◆text1(03)◆ -" "◇text2◇
		text += " "

		// "◆"text1(03)◆ - "◇"text2◇
		if( i == l1 )
			text += "◆"
		else
			text += "◇"

		// ◆"text1"(03)◆ - ◇"text2"◇
		text += KSGUI_L1_TEXT[i]

		// ◆text1"(03)"◆ - ◇text2◇
		if( i == 0 )
			text += "("+ player.s.NukeTitan +")"
		if( i == 1 )
			text += "("+ player.s.CruiseMissile +")"

		// ◆text1(03)"◆" - ◇text2"◇"
		if( i == l1 )
			text += "◆"
		else
			text += "◇"

		// ◆text1(03)◆" "- ◇text2◇" "
		text += " "
	}
	if( onlyShowBatteryElem || ( skipL1Elem.contains( 4 ) && skipL1Elem.contains( 5 ) ) )
		text += "\n"
	text += "\n\n\n\n\n\n"

	table<int> ksData = GetKillStreakData()
	text += "铁驭生命值:"+ player.GetHealth() +"/"+ player.GetMaxHealth() +"    护甲生命值:"+ player.GetShieldHealth() +"/"+ player.GetShieldHealthMax() +"\n"
	text += "\n====== 连杀奖励获取进度 ======\n"
	text += "总杀["+ GetProgress( expect int( player.s.TotalKills ) % ksData.nukeTitan, ksData.nukeTitan ) + "]核武泰坦\n"
	text += "总杀["+ GetProgress( expect int( player.s.TotalKills ) % ksData.cruiseMissile, ksData.cruiseMissile ) + "]巡弋飞弹\n"
	text += "连续击杀["+ GetProgress( expect int( player.s.KillStreakNoNPC ) % ksData.nuclearBomb, ksData.nuclearBomb ) + "]折叠时空武器\n"
	return text
}

void function KsGUI_SelectL1( entity player )
{
	player.s.GUIActive = false

	local l1 = player.s.KsGUIL1
	if( l1 == 0 )
		return KeepingApplyNukeTitan( player )
	if( l1 == 1 )
		return ApplyCruiseMissile( player )
    if( l1 == 2 )
        return ApplyVTOL( player )
	if( l1 == 3 )
		return ApplyNuclearBomb( player )
	if( l1 == 4 )
		return ApplyDropBattery( player )
	if( l1 == 5 )
		return ApplyShieldBattery( player )
}

void function KeepingApplyNukeTitan( entity player )
{
	int applytimes = 0
	for( ;; )
	{
		ApplyNukeTitan( player )
		wait GraphCapped( applytimes, 0, 3, 0.5, 0.2 )
		applytimes++
	}
}

string function GetProgress( int val, int endVal )
{
	int sysbolNum = int( GraphCapped( val, 0, endVal, 0, 20 ) )
	string text = ""
	for( int i = sysbolNum; i > 0; i-- )
		text += "/"
	for( int i = 20 - sysbolNum; i > 0; i-- )
		text += "-"
	return text
}
