// I tried to make many things into functions and use waitthread, but it messes everything up.
// SOLVED IT! just use signals instead of those shitty fast loops.

untyped //Panel.s stuff needs to be typed

global function RodeoTitan_Init

global function EnableTitanRodeo
global function DisableTitanRodeo
global function DebugRodeoTimes
global function PlayerBeginsTitanRodeo
global function ForceTitanRodeoToEnd
global function PlayerRodeoViewCone
global function OpenViewCone
global function RodeoPanelIsOpen
global function PlayerRemovesBatteryPack
global function Rodeo_PilotAddsBatteryToFriendlyTitan
global function GiveFriendlyRodeoPlayerProtection
global function TakeAwayFriendlyRodeoPlayerProtection
global function Rodeo_GiveBatteryToPlayer
global function Rodeo_PilotThrowsBattery

global function Rodeo_TakeBatteryAwayFromPilot

global function Rodeo_RemoveBatteryOffPlayer
global function Rodeo_RemoveAllBatteriesOffPlayer
global function Rodeo_GiveExecutingTitanABattery
global function Rodeo_CreateBatteryPack
global function SetSoulBatteryCount
global function GetPlayerBatteryCount
global function PlayerHasMaxBatteryCount

// globalled for nessie
global function Rodeo_PilotPicksUpBattery
global function Rodeo_PilotPicksUpBattery_Silent

global function AddOnRodeoStartedCallback
global function AddOnRodeoEndedCallback

global function PilotBattery_SetMaxCount
global function ThrowRiderOff

global function Burnmeter_EmergencyBattery
global function Burnmeter_AmpedBattery

global function Battery_StartFX
global function Battery_StopFX
global function Battery_StopFXAndHideIconForPlayer

global function RemovePlayerAirControl //This function should really be in a server only SP & MP utility script file. No such file exists as of right now.
global function RestorePlayerAirControl //This function should really be in a server only SP & MP utility script file. No such file exists as of right now.

// classic rodeo
global function ClassicRodeo_SetEnabled
global function ClassicRodeo_IsEnabled

global function ClassicRodeo_SetStarterBatteryCount
global function ClassicRodeo_AllowContinouslyRemoveBattery // this will make players able to remove batteries until
global function ClassicRodeo_SetBatteryRemovalDamageAmped // this will make removing batteries also removing titan's shield, and rodeo grenade will deal 2x damage
global function ClassicRodeo_BatteryContainerOnlyProtectsOnce // every titan only have one battery protects their panel like ttf1's panel
//global function ClassicRodeo_OwnerApplyBatteryAllowed // owner can't add battery count to their titans
// fuck once I thought this can be enabled to vanilla rodeo mechanic and tried to make it a independent mechanic!
global function ClassicRodeo_SetShouldAutomaticallyDoRodeoSequence // player won't remove batteries or do other sequences if they're not inputing anything

global function ClassicRodeo_IsPlayerRemovingBatteryPack
global function ClassicRodeo_IsPlayerThrowingGrenadeInHatch

// nessie modify
global function Rodeo_SetBatterySkinRandom
global function IsBatteryNowRandom
global function Rodeo_SetBatteryThrowEnabled
global function IsBatteryThrowEnabled

global function Rodeo_SetBatteryIconsHide
global function Rodeo_SetWorldBatteryMaxCount
global function Rodeo_SetBatteryPickupAllowed

#if DEV
global function SetDebugRodeoPrint
global function GetDebugRodeoPrint
#endif

#if MP
global function SetApplyBatteryCallback
#endif

const float BATTERY_PICKUP_IGNORE_FRAC = 0.98
const RODEO_EXPLOSION_DAMAGEFRAC = 0.3
global const RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS = $"models/props/titan_battery_static/titan_battery_static.mdl" //Need a separate one for rodeo anims, instead of manually rotating the existing one
const RODEO_BATTERY_RIP_PILOT_PUSHED_OFF_VERTICAL_HEIGHT = 80
const RODEO_BATTERY_RIP_PILOT_PUSHED_OFF_HORIZONTAL_SPEED = 450
const RODEO_THROW_BATTERY_BUTTON_HOLD_TIME = 0.5
const RODEO_CLAMBER_FAILED_SOUND_DEBOUNCE_TIME = 2.0
global const BATTERY_FX_FRIENDLY = $"P_xo_battery"
global const BATTERY_FX_AMPED = $"P_xo_battery_amped"

const HAS_BATTERY_THIEF_ICON = false

const string PILOT_PICKS_UP_BATTERY_SOUND = "UI_TitanBattery_Pilot_PickUp"
const string PILOT_APPLIES_BATTERY_TO_TITAN_HEALTH_RESTORED_SOUND = "UI_TitanBattery_Pilot_Give_TitanBattery"


global int RODEO_BATTERY_EXPLOSION_EFFECT

const string TITAN_GOT_BATTERY_RIPPED_SOUND = "UI_TitanBattery_Pilot_Take_TitanBattery"

global float ANTI_RODEO_DEFAULT_START_DELAY = 0.5
global float ANTI_RODEO_DEFAULT_DRAIN_DURATION = 1.25
global float ANTI_RODEO_DEFAULT_WINDOW_DURATION = 0.1
global float ANTI_RODEO_DEFAULT_WINDOW_START = 0.55

//nessie modify
const int PILOT_BATTERY_BUGGED_LIMIT = 1
const int WORLD_BATTERY_MAX_COUNT_DEFAULT = 32

struct AntiRodeoPlayerData
{
	bool antiRodeoPressed
	float startTime
	float windowStartFrac
	float windowEndFrac
	entity antiRodeoPlayer
	bool wasCrouched
}

struct
{
	array<void functionref(entity,entity)> onRodeoEndedCallbacks
	array<void functionref(entity,entity)> onRodeoStartedCallbacks

	table<entity, AntiRodeoPlayerData> antiRodeoPlayerData

	int maxPilotBatteryCount = 1
	bool debugRodeoPrint = false

	table<entity, bool> playersThatWantToUseRodeoGrenade

	void functionref(entity,entity,entity) applyBatteryCallback

	// classic rodeo
	bool classicRodeoEnabled = true
	int classicRodeoStarterBatteryCount = 1 // titans start with this battery count
	bool continouslyRemoveBattery = false
	bool batteryRemovalDamageAmped = false
	bool batteryContainerOnlyProtectsOnce = false
	//bool ownerApplyBatteryAllowed = true
	bool automaticallyDoRodeoSequence = false

	// nessie modify
	int worldBatteryMaxCount = WORLD_BATTERY_MAX_COUNT_DEFAULT
	bool canThrowBattery = false
	bool shouldRandomBattery = false
	bool alwaysHideBatteryIcons = false
	bool batteryPickUp = false
} file

//-----------------------------------------------------------------------------
//  _rodeo_titan.nut
//
//  Script for a player (pilot) rodoeing a titan.
//
//-----------------------------------------------------------------------------

void function RodeoTitan_Init()
{
	PrecacheParticleSystem( $"P_impact_rodeo_damage" ) //Rodeo hit spark
	PrecacheParticleSystem( $"P_rodeo_damage_1" )  //DamageState1
	PrecacheParticleSystem( $"P_rodeo_damage_2" )  //DamageState2
	PrecacheParticleSystem( $"P_rodeo_damage_3" )  //DamageState3
	PrecacheParticleSystem( BATTERY_FX_FRIENDLY )
	PrecacheParticleSystem( BATTERY_FX_AMPED )

	RegisterSignal( "CancelAirControlLoss" )
	RegisterSignal( "FriendlyRodeoDeployWeapon" )
	RegisterSignal( "MonitorRodeoPastPointOfNoReturn" )
	RegisterSignal( "PostRodeoAirControl" )

	PrecacheModel( RODEO_BATTERY_MODEL )
	PrecacheModel( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	//nessie WTF
	PrecacheModel( $"models/domestic/nessy_doll.mdl" )

	AddSoulDeathCallback( SoulRodeoEnds )
	AddSoulTransferFunc( RecreateRodeoPanelDamageFX )

	RODEO_BATTERY_EXPLOSION_EFFECT = PrecacheParticleSystem( $"P_impact_exp_FRAG_metal" )

	AddCallback_OnPlayerKilled( Rodeo_DropAllBatteriesOnDeath )
	AddCallback_OnTouchHealthKit( "item_titan_battery", Rodeo_OnTouchBatteryPack )
	AddCallback_OnPilotBecomesTitan( Rodeo_ApplyAllBatteriesOnEmbark )

	//AddSoulInitFunc( Rodeo_HealthDecayThink )

	if ( IsMultiplayer() )
	{
		//AddDeathCallback( "player", TitanDropsBatteryOnDeath ) //SP has its own functions. Maybe we should just copy SP's stuff? They have the green highlight FX for it too
		//AddDeathCallback( "npc_titan", TitanDropsBatteryOnDeath ) //SP has its own functions. Maybe we should just copy SP's stuff? They have the green highlight FX for it too

		AddDamageCallback( "player", ShowRequestRodeoBatteryHint_OnDamage )
		AddCallback_OnPilotBecomesTitan( ShowRequestRodeoBatteryHint_OnPilotBecomesTitan )

		AddClientCommandCallback( "OfferRodeoBattery", ClientCommand_OfferRodeoBattery )
		AddClientCommandCallback( "RequestRodeoBattery", ClientCommand_RequestRodeoBattery )

		#if MP
		AddClientCommandCallback( "TryNukeGrenade", ClientCommand_TryNukeGrenade )
		RegisterSignal( "TryNukeGrenade" )
		RegisterSignal( "RodeoNukeWindowEnded" )
		#endif

		// nessie move
		AddSoulInitFunc( DisableBTRodeo )
	}
	//else // bt rodeo has been fixed
	//{
		//AddSoulInitFunc( DisableBTRodeo )
	//}

	///// modified /////
	RegisterSignal( "RodeoDefensiveSequence" ) // apply battery
	RegisterSignal( "RodeoOffensiveSequence" ) // throw grenade, remove battery

	RegisterSignal( "ClassicRodeoThink" )
	RegisterSignal( "RodeoSequenceThink" )
	RegisterSignal( "RodeoWeakPointThink" )

	RegisterSignal( "RodeoBatteryRemoval" )
	RegisterSignal( "ApplyBatteryToTitan" )
	RegisterSignal( "PlayerAppliesBatteryPack" )
	RegisterSignal( "PlayerRemovesBatteryPack" )
	RegisterSignal( "PlayerThrowsGrenadeInHatch" )

	AddSpawnCallback( "player", ClassicRodeo_InitPlayerSettings )
	AddSpawnCallback( "npc_titan", ClassicRodeo_InitTitanSettings )
	AddDeathCallback( "player", ClassicRodeo_DropAllStoredBatteries )
	AddDeathCallback( "npc_titan", ClassicRodeo_DropAllStoredBatteries )
	AddCallback_OnPilotBecomesTitan( ClassicRodeo_UpdateBatteryContainer )
	AddCallback_OnTitanBecomesPilot( ClassicRodeo_UpdateBatteryContainer )
	/////          /////
}

void function Rodeo_HealthDecayThink( entity soul ) //Remove if we don't want rodeo battery to drain health
{
	thread Rodeo_HealthDecayThinkInternal( soul )
}

void function Rodeo_HealthDecayThinkInternal( entity soul ) //Remove if we don't want rodeo battery to drain health
{
	soul.EndSignal( "OnDestroy" ) //This needs to be OnDestroy instead of OnDeath because souls don't have a death animation
	soul.EndSignal( "OnTitanDeath" )

	bool draining = false

	while ( 1 )
	{
		entity titan = soul.GetTitan()

		if ( Rodeo_ShouldDrainHealth( soul ) )
		{
			if ( !draining )
			{
				draining = true
				EmitSoundOnEntity( titan, "titan_energyshield_down" )
			}

			int damageAmout = Rodeo_GetDrainAmount( soul )

			titan.TakeDamage( damageAmout, soul.e.lastRodeoAttacker, soul.e.lastRodeoAttacker, { scriptType = damageTypes.rodeoBatteryRemoval | DF_NO_INDICATOR, damageSourceId = eDamageSourceId.rodeo_battery_removal, hitbox = 2 } )
		}
		else
		{
			if ( draining )
			{
				draining = false
				StopSoundOnEntity( titan, "titan_energyshield_down" )
			}
		}
		WaitFrame()
	}
}

bool function Rodeo_ShouldDrainHealth( entity soul ) //Remove if we don't want rodeo battery to drain health
{
	entity titan = soul.GetTitan()
	if ( !IsAlive( titan ) )
		return false

	if ( GetDoomedState( titan ) )
		return false

	int batt = GetSoulBatteryCount( soul )
	int maxBattHealth = GetSegmentHealthForTitan( titan ) * batt
	int health = titan.GetHealth()
	return ( health > maxBattHealth )
}

int function Rodeo_GetDrainAmount( entity soul ) //Remove if we don't want rodeo battery to drain health
{
	entity titan = soul.GetTitan()

	float damagePerSec = GetSegmentHealthForTitan( titan ) / RODEO_DRAIN_TIME
	float damagePerFrame = ceil( GetSegmentHealthForTitan( titan ) / RODEO_DRAIN_TIME ) * 0.1
	int damageAmout =  int( damagePerFrame )

	int batt = GetSoulBatteryCount( soul )
	int maxBattHealth = GetSegmentHealthForTitan( titan ) * batt
	int health = titan.GetHealth()
	if ( health - maxBattHealth < damageAmout )
		damageAmout = health - maxBattHealth

	return damageAmout
}

void function GiveFriendlyRodeoPlayerProtection( entity titan )
{
	entity friendlyRider = GetFriendlyRodeoPilot( titan )
	if ( IsValid( friendlyRider ) )
	{
		//printt( "Set friendlyRider PassDamageToParent true" )
		friendlyRider.kv.PassDamageToParent = true //rodeo player now passes damage to titan
	}
}

void function TakeAwayFriendlyRodeoPlayerProtection( entity titan )
{
	entity friendlyRider = GetFriendlyRodeoPilot( titan )
	if ( IsValid( friendlyRider ) )
	{
		//printt( "Set friendlyRider PassDamageToParent false" )
		friendlyRider.kv.PassDamageToParent = false //rodeo player now takes full damage
	}
}

void function CreateSparksInsideTitanPanel( panel )
{
	entity impactSpark = CreateEntity( "info_particle_system" )
	impactSpark.kv.start_active = 1
	impactSpark.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	impactSpark.SetValueForEffectNameKey( $"P_impact_rodeo_damage" )
	SetTargetName( impactSpark, UniqueString() )
	impactSpark.SetParent( panel, "hatch", false, 0 )
	DispatchSpawn( impactSpark )
	impactSpark.Kill_Deprecated_UseDestroyInstead( 1.5 )
}


void function CreateDamageStateParticlesForPanel( var panel, asset particleSystem = $"P_impact_rodeo_damage" )
{
	entity impactSpark = CreateEntity( "info_particle_system" )
	impactSpark.kv.start_active = 1
	impactSpark.SetOwner( panel.GetParent() )
	impactSpark.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not visible to owner
	impactSpark.SetValueForEffectNameKey( particleSystem )
	SetTargetName( impactSpark, UniqueString() )
	impactSpark.SetParent( panel, "hatch", false, 0 )
	DispatchSpawn( impactSpark )
	if ( IsValid( panel.s.lastDamageStateParticleSystem ) )
	{
		//printt("Killing particle system: " + panel.s.lastDamageStateParticleSystem)
		panel.s.lastDamageStateParticleSystem.Kill_Deprecated_UseDestroyInstead()
	}

	panel.s.lastDamageStateParticleSystem = impactSpark
}


void function RecreateRodeoPanelDamageFX( entity soul, entity titan, entity oldTitan )
{
	thread RecreateRodeoPanelDamageFX_threaded( soul )
}


void function RecreateRodeoPanelDamageFX_threaded( entity soul )
{
	WaitEndFrame()
	entity panel = soul.soul.batteryContainer

	if (! IsValid( panel ) )
		return

	entity lastDamageStateParticleSystem = expect entity ( panel.s.lastDamageStateParticleSystem )

	if ( IsValid( lastDamageStateParticleSystem ) )
	{
		CreateDamageStateParticlesForPanel( panel, lastDamageStateParticleSystem.GetValueForEffectNameKey() ) //This kills the last particle system too
	}
}

void function RodeoPanelIsOpen( entity panel )
{
	panel.s.opened = true

	entity titan = panel.GetParent()
	Assert( titan.IsTitan() )

	entity soul = titan.GetTitanSoul()
	Assert( IsValid( soul ) )

	soul.SetLastRodeoHitTime( Time() ) //Make warning always trigger now when panel is ripped
	soul.soul.batteryContainerBeingUsed = false
}

void function RodeoBatteryRemoval( entity pilot )
{
	entity titan = GetTitanBeingRodeoed( pilot )
	if ( !IsValid( titan ) )
		return

	// THROW RODEO RIDER OFF
	entity soul = titan.GetTitanSoul()
	string titanType = GetSoulTitanSubClass( soul )

	soul.SetLastRodeoHitTime( Time() )

	RodeoBatteryPackRemovalDamage( pilot, titan, soul )

	bool playerHadBattery = PlayerHasBattery( pilot )
	bool classicRodeo = ClassicRodeo_IsEnabled()

	// for classic rodeo
	if ( !playerHadBattery )
	{
		AddPlayerScore( pilot, "PilotBatteryStolen", pilot ) // not using titan as association entity, don't know weather good
		if( !classicRodeo || ClassicRodeo_GetSoulBatteryCount( soul ) >= 1 ) // check for classic rodeo throwing grenades
		{
			entity battery = Rodeo_CreateBatteryPack( titan ) // this also make batteries a owner, so titans can't instant pick them back if "pickUpAllowed"
			Rodeo_PilotPicksUpBattery( pilot, battery )
			thread BatteryThiefHighlight( pilot )
		}

		if ( titan.IsPlayer() )
		{
			EmitSoundOnEntityOnlyToPlayer( titan, titan, TITAN_GOT_BATTERY_RIPPED_SOUND ) //Consider playing this in world once we get sounds that aren't just notification beeps
		}
	}

	vector direction = CalculateDirectionToThrowOffBatteryThief( pilot, titan )

	// for classic rodeo, let pilots stay on titans if they don't have batteris left
	bool shouldThrowOff = true
	if( classicRodeo && ClassicRodeo_GetSoulBatteryCount( soul ) - 1 < 1 )
		shouldThrowOff = false
	if( file.continouslyRemoveBattery ) // also let players stay on titan if it's able to remove multiple batteries
		shouldThrowOff = false
	if( shouldThrowOff ) // titan still have battery after removal!
		ThrowRiderOff( pilot, titan, direction ) //This signals RodeoOver

	if( classicRodeo )
	{
		//print( "Signaled \"RodeoBatteryRemoval\"!" )
		pilot.Signal( "RodeoBatteryRemoval" ) // for throwing off pilots after throwing grenades
		if( playerHadBattery && ClassicRodeo_GetSoulBatteryCount( soul ) >= 1 )
		{ // additional battery
			AddPlayerScore( pilot, "PilotBatteryStolen", pilot )
			entity battery = Rodeo_CreateBatteryPack( titan )
			if( !PlayerHasMaxBatteryCount( pilot ) )
				Rodeo_PilotPicksUpBattery( pilot, battery )
			else
			{
				battery.SetOrigin( pilot.GetAttachmentOrigin( pilot.LookupAttachment( "BATTERY_ATTACH" ) ) )
				battery.SetAngles( < 0, 0, 0 > )
				battery.SetVelocity( titan.GetVelocity() + < 0,0,1 > ) // if not working well, should use < 0,0,1 >
			}
			if( titan.IsPlayer() )
				EmitSoundOnEntityOnlyToPlayer( titan, titan, TITAN_GOT_BATTERY_RIPPED_SOUND ) // notify titan
		}
		if( file.batteryContainerOnlyProtectsOnce ) // remove all batteries if this is enabled
			ClassicRodeo_SetSoulBatteryCount( soul, 0 )
		else
			ClassicRodeo_RemoveSoulBattery( soul )
	}

	#if MP
		PIN_PlayerRodeoedEnemyTitanToCompletion( pilot, titan, playerHadBattery )
	#endif
}

void function RodeoBatteryGrenadeShow( entity pilot )
{
	entity titanSoul = pilot.GetTitanSoulBeingRodeoed()
	Assert( IsValid( titanSoul ) )

	foreach( tempProp in pilot.p.rodeoAnimTempProps )
	{
		tempProp.Show()
	}
}

void function RodeoBatteryRemoval_ShowBattery( entity pilot )
{
	foreach( tempProp in pilot.p.rodeoAnimTempProps )
	{
		tempProp.Show()
	}

	entity titanSoul = pilot.GetTitanSoulBeingRodeoed()

	string titanType = GetSoulTitanSubClass( titanSoul )

	entity batteryContainer = titanSoul.soul.batteryContainer
	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down_idle" )  )

}


void function RodeoBatteryStealthMovementWarning( entity pilot )
{
	if ( !PlayerHasPassive( pilot, ePassives.PAS_STEALTH_MOVEMENT ) )
		return

	entity titanSoul = pilot.GetTitanSoulBeingRodeoed()

	titanSoul.SetLastRodeoHitTime( Time() ) //This shows the warning icon on the Titan's hud
}

vector function CalculateDirectionToThrowOffBatteryThief( entity batteryThief, entity titan, bool classicRodeoGrenade = false )
{
	vector backward
	vector right
	float baseZvec = RODEO_BATTERY_RIP_PILOT_PUSHED_OFF_VERTICAL_HEIGHT
	// for classicRodeoGrenades, player won't have chance to press jump, so add a jump vector( z += 220 )
	if( classicRodeoGrenade )
		baseZvec += 220

	if( !IsValid( titan ) )
		return <0, 0, baseZvec>

	if ( titan.IsPlayer() )
	{
		backward = titan.GetViewForward() * -1.0
		right = titan.GetViewRight()
	}
	else
	{
		backward = titan.GetForwardVector() * -1.0
		right = titan.GetRightVector()
	}

	backward.z = 0
	right.z = 0

	backward = Normalize( backward )
	right = Normalize( right )

	// map the player's controls to his angles, and add that velocity
	float xAxis = batteryThief.GetInputAxisRight()
	float yAxis = batteryThief.GetInputAxisForward()

	xAxis = GraphCapped( xAxis, -1.0, 1.0, -0.4, 0.4 )
	yAxis = GraphCapped( yAxis, -1.0, 1.0, 1.0, 0.75 ) //Cap it so you don't actually let the players jump forwards

	vector direction
	if ( fabs( xAxis ) < 0.2 && fabs( yAxis ) < 0.2 )
	{
	    // no significant controller deflection, just push forward by 0.75 as default
	    direction = backward * 0.75
	}
	else
	{
	    vector forwardVec = backward * yAxis
	    vector rightVec = right * xAxis
	    direction = rightVec + forwardVec
	}

	direction *= RODEO_BATTERY_RIP_PILOT_PUSHED_OFF_HORIZONTAL_SPEED
	direction.z = baseZvec

	// JFS: R2DLC-310 SCRIPT ERROR: PHONE_HOME: [SERVER] vecAbsVelocity isn't valid
	if ( LengthSqr( direction ) < 0.0 )
		return <0, 0, baseZvec>

	return direction
}

void function CancelAirControlLossAfterTouchGround( entity player )
{
	player.Signal( "CancelAirControlLoss" )
}


void function BatteryThiefHighlight( entity player )
{
	Highlight_SetEnemyHighlight( player, "battery_thief" )

	OnThreadEnd(
		function() : ( player )
		{
			if ( !IsValid( player ) )
				return

			if ( Hightlight_HasEnemyHighlight( player, "battery_thief" ) )
				Highlight_ClearEnemyHighlight( player )
		}
	)

	wait RODEO_BATTERY_THIEF_ICON_DURATION
}

void function ForceTitanRodeoToEnd( entity titan ) //TODO: Not typed since it is added via anim event
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	SoulRodeoEnds( soul, null )
}


void function SoulRodeoEnds( entity soul, var damageInfo )
{
	entity titan = soul.GetTitan()

	if( !IsValid( titan ) )
		return

	entity rider = GetRodeoPilot( titan )

	if ( !IsValid( rider ) )
		return

	rider.Signal( "RodeoOver" )
	rider.ClearParent()
}


void function EnableTitanRodeo( entity titan )
{
	Assert( titan.IsTitan(), "tried calling EnableTitanRodeo on non-titan" )

	entity titanSoul = titan.GetTitanSoul()

	Assert( IsValid( titanSoul ) )

	titanSoul.SetIsValidRodeoTarget( true ) //Lets rodeo happen on them.
}


void function DisableTitanRodeo( entity titan )
{
	Assert( titan.IsTitan(), "tried calling DisableTitanRodeo( on non-titan" )

	entity titanSoul = titan.GetTitanSoul()

	Assert( IsValid( titanSoul ) )

	titanSoul.SetIsValidRodeoTarget( false ) //Stops rodeo from happening on them.
}

void function AddOnRodeoStartedCallback( void functionref(entity,entity) callbackFunc )
{
	Assert (!( file.onRodeoStartedCallbacks.contains( callbackFunc ) ))
	file.onRodeoStartedCallbacks.append( callbackFunc )
}

void function AddOnRodeoEndedCallback( void functionref(entity,entity) callbackFunc )
{
	Assert (!( file.onRodeoEndedCallbacks.contains( callbackFunc ) ))
	file.onRodeoEndedCallbacks.append( callbackFunc )
}

function PlayerBeginsTitanRodeo( entity player, RodeoPackageStruct rodeoPackage, entity rodeoTitan )
{
	entity soul = rodeoTitan.GetTitanSoul()
	Assert( IsValid( soul ) )

	bool sameTeam = player.GetTeam() == rodeoTitan.GetTeam()
	bool playerWasEjecting = player.p.pilotEjecting // have to store this off here because the "RodeoStarted" signal below ends eject, so it will be too late to check it in actual rodeo function. Used to check for eject -> rodeo

	player.p.rodeoShouldAdjustJumpOffVelocity = true

	player.Signal( "RodeoStarted" )

	bool playerHadBatteryAtStartOfRodeo = PlayerHasBattery( player )

	OnThreadEnd(
		function () : ( player, soul, sameTeam, rodeoTitan, playerHadBatteryAtStartOfRodeo )
		{
			RodeoPackageStruct rodeoPackage = player.p.rodeoPackage
			entity newRodeoTitan = rodeoTitan

			//Clear the rodeo alert and update the newRodeoTitan to be the soul's titan
			if ( IsValid( soul ) )
			{
				soul.SetLastRodeoHitTime( 0 ) //Clear rodeo warning for next time a player jumps on
				newRodeoTitan = soul.GetTitan() //rodeoTitan might have changed because a player embarked/disembarked etc

				foreach ( callbackFunc in file.onRodeoEndedCallbacks )
				{
					callbackFunc( player, newRodeoTitan )
				}

				for( int i = 0; i < soul.rodeoReservedSlots.len(); ++i )
				{
					if ( soul.rodeoReservedSlots[ i ] == player )
					{
						soul.rodeoReservedSlots[ i ] = null
						break
					}
				}

				if ( soul.soul.batteryContainerBeingUsed && playerHadBatteryAtStartOfRodeo ) //i.e. rodeo got interruped early
				{
					string titanType = GetSoulTitanSubClass( soul )
					entity batteryContainer = soul.soul.batteryContainer
					// was ( sameTeam && ClassicRodeo_GetSoulBatteryCount( soul ) >= 1 ), removed since we supporting applying battery to enemy titans now
					if( !ClassicRodeo_IsEnabled() || ( soul.soul.batteryMovedDown && ClassicRodeo_GetSoulBatteryCount( soul ) >= 1 ) )
						batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
					soul.soul.batteryContainerBeingUsed = false
				}

				// if the player is invalid, we still need to enable rodeo on the titan
				// normally this would happen in Rodeo_Detach(), but that only works if the player is valid
				if ( !IsValid( player ) )
					EnableTitanRodeo( newRodeoTitan )
			}

			if ( IsValid( player ) )
			{
				// for classic rodeo condition: clean up.
				ClassicRodeo_SettingsCleanUp( player )

				player.Signal( "RodeoOver" )
				player.SetNameVisibleToFriendly( true ) // show name of the pilot again
				player.SetNameVisibleToEnemy( true )
				ClearPlayerAnimViewEntity( player )
				player.AnimViewEntity_SetLerpOutTime( 0.4 ) // blend out the clear anim view entity
				player.ClearParent()
				player.Anim_Stop()
				player.SetOneHandedWeaponUsageOff()
				player.SetTitanSoulBeingRodeoed( null )
				player.UnforceStand()
				player.kv.PassDamageToParent = false
				player.TouchGround() // so you can double jump off
				StopSoundOnEntity( player, rodeoPackage.cockpitSound )
				StopSoundOnEntity( player, rodeoPackage.worldSound )
				if ( Rodeo_IsAttached( player ) )
					Rodeo_Detach( player )

				if ( IsAlive( player ) )
				{
					vector startPos = player.GetOrigin()
					entity entToTeleport = player
					if ( IsValid( newRodeoTitan ) )
					{
						entToTeleport = newRodeoTitan
						int attachIndex = newRodeoTitan.LookupAttachment( rodeoPackage.attachPoint )
						if( attachIndex != 0 )	// defensive fix for some time soul can be invalid, at this time the newRodeoTitan is a human, will return a invalid attachIndex
							startPos = newRodeoTitan.GetAttachmentOrigin( attachIndex )
					}

					if ( !PlayerCanTeleportHere( player, startPos, entToTeleport ) )
					{
						startPos = entToTeleport.GetOrigin()
						if ( !PlayerCanTeleportHere( player, startPos, entToTeleport ) )
							startPos = player.GetOrigin()
					}

					thread PlayerJumpsOffRodeoTarget( player, newRodeoTitan, startPos )
				}

				#if MP
				player.Signal( "RodeoNukeWindowEnded" )
				if ( player in file.playersThatWantToUseRodeoGrenade )
					delete file.playersThatWantToUseRodeoGrenade[ player ]
				#endif
			}
		}
	)


	soul.EndSignal( "OnTitanDeath" )
	soul.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "RodeoOver" )

	string rodeoTitanType = rodeoPackage.rodeoTargetType

	#if MP
		thread OpenRodeoNukeWindow( player, rodeoTitan )
	#endif

	thread WatchForPlayerJumpingOffRodeo( player )

	// hide name of the pilot while he is rodeoing
	player.SetNameVisibleToFriendly( false )
	player.SetNameVisibleToEnemy( false )
	player.ForceStand()
	thread ManagePlayerWeaponDeployment( player, soul ) //Spin this off in its own thread since there are multiple ways for weapon to be deployed
	player.SetOneHandedWeaponUsageOn()
	player.TouchGround() // so you can double jump off
	player.SetTitanSoulBeingRodeoed( soul )

	if ( soul.GetShieldHealth() > 0.0 )   // This was not evaluating properly with 0 being an int, so make it a float which works
		GiveFriendlyRodeoPlayerProtection( rodeoTitan )

	foreach ( callbackFunc in file.onRodeoStartedCallbacks )
		callbackFunc( player, rodeoTitan )

	if ( player.GetTeam() != rodeoTitan.GetTeam() && !PlayerHasPassive( player, ePassives.PAS_STEALTH_MOVEMENT ) )
		soul.SetLastRodeoHitTime( Time() ) // Alert Titan immediately if you don't have passive

	bool shouldMoveDownBattery = false
	bool classicRodeo = ClassicRodeo_IsEnabled()

	if( classicRodeo )
	{
		if( ClassicRodeo_GetSoulBatteryCount( soul ) >= 1 && PilotCanApplyBattery( player, rodeoTitan ) ) // titan is teamMate and it already have a battery
			shouldMoveDownBattery = true
		else if( !ClassicRodeo_ShouldRemoveBattery( soul ) )
			shouldMoveDownBattery = true
	}
	else // vanilla game
	{
		if( ShouldThrowGrenadeInHatch( player ) )
			shouldMoveDownBattery = true
	}

	if( !file.automaticallyDoRodeoSequence ) // never move batteries if player have to apply manually
		shouldMoveDownBattery = false

	soul.soul.batteryMovedDown = false
	if ( shouldMoveDownBattery ) //Either player is going to apply a battery, or it's going to throw a grenade. In either case, we want the battery to move
	{
		Rodeo_MoveBatteryDown( soul )
	}

	soul.soul.batteryContainerBeingUsed = true //All rodeo points mark batteryContainer as being true, various exit points mark it as being false when they are done cleaning it up (e.g. playing the appropriate battery going up/down anims)

	if ( !sameTeam )
	{
		#if FACTION_DIALOGUE_ENABLED
			thread PlayRodeoFactionDialogueAfterDelay( player, 0.5 )
		#endif
		TitanVO_AlertTitansTargetingThisTitanOfRodeo( player, soul )
	}

	waitthread PlayerClimbsIntoRodeoPosition( player, rodeoTitan, rodeoPackage, playerWasEjecting )

	if( classicRodeo )
	{
		// for classic rodeo: some animation will cause player unable to end rodeo
		thread ClassicRodeo_AllowForceEndRodeoLifeLong( player )
	}

	#if MP
		player.Signal( "RodeoNukeWindowEnded" )
	#endif

	// There has been a wait, verify things are still valid.

	if ( !IsValid( soul ) )
		return

	entity rodeoTitan = soul.GetTitan()

	if ( !IsAlive( rodeoTitan ) )
		return

	TryBatteryStyleRodeo( player, rodeoTitan, soul, rodeoPackage )
}

#if FACTION_DIALOGUE_ENABLED
void function PlayRodeoFactionDialogueAfterDelay( entity player, float delay = 0.5 )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "RodeoOver" )

	wait delay
	PlayFactionDialogueToPlayer( "kc_rodeo", player )
}
#endif

void function Rodeo_MoveBatteryDown( entity soul )
{
	if ( soul.soul.batteryMovedDown )
		return

	string titanType = GetSoulTitanSubClass( soul )
	entity batteryContainer = soul.soul.batteryContainer
	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down" ) )
	soul.soul.batteryMovedDown = true
}

void function ManagePlayerWeaponDeployment( entity player, entity titanSoul )
{
	HolsterAndDisableWeapons( player )

	titanSoul.EndSignal( "OnTitanDeath" )
	titanSoul.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "RodeoOver" )
	player.EndSignal( "FriendlyRodeoDeployWeapon" )

	OnThreadEnd(
	function() : ( player )
		{
			DeployAndEnableWeapons( player )
		}
	)

	while( true ) // defensive fix
	{
		player.HolsterWeapon()
		player.Server_TurnOffhandWeaponsDisabledOn()

		WaitFrame()
	}
}


vector function GetAntiRodeoThrowOffDirection( entity rodeoRider, entity titan )
{
	vector backward
	vector right

	if ( titan.IsPlayer() )
	{
		backward = titan.GetViewForward() * -1.0
		right = titan.GetViewRight()
	}
	else
	{
		backward = titan.GetForwardVector() * -1.0
		right = titan.GetRightVector()
	}

	backward.z = 0
	right.z = 0

	// map the player's controls to his angles, and add that velocity
	float xAxis = rodeoRider.GetInputAxisRight()
	float yAxis = rodeoRider.GetInputAxisForward()

	xAxis = GraphCapped( xAxis, -1.0, 1.0, -0.4, 0.4 )
	yAxis = GraphCapped( yAxis, -1.0, 1.0, 1.0, 0.75 ) //Cap it so you don't actually let the players jump forwards

	vector direction
	if ( fabs( xAxis ) < 0.2 && fabs( yAxis ) < 0.2 )
	{
		// no significant controller deflection, just push forward by 0.75 as default
		direction = backward * 0.75
	}
	else
	{
		vector forwardVec = backward * yAxis
		vector rightVec = right * xAxis
		direction = rightVec + forwardVec
	}

	direction *= 600
	direction.z = 25

	return direction
}

void function RodeoPilotPullsOutWeapon( entity rodeoPilot, entity rodeoTitan, string rodeoTitanType )
{
	PlayerRodeoViewCone( rodeoPilot, rodeoTitanType )

	Rodeo_OnFinishClimbOnAnimation( rodeoPilot ) // This is to let code know the rodeoPilot has finished climbing on the rodeo and ready to fire
	rodeoPilot.Signal( "FriendlyRodeoDeployWeapon" )
}

void function TryBatteryStyleRodeo( entity rodeoPilot, entity rodeoTitan, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	titanSoul.EndSignal( "OnTitanDeath" )

	string rodeoTitanType = rodeoPackage.rodeoTargetType

	bool isPlayerTitan = rodeoTitan.IsPlayer()
	// this means not creating a weakpoint or ripping battery, perfer applying battery
	bool sameTeam = rodeoPilot.GetTeam() == rodeoTitan.GetTeam()
	bool shouldDoFriendlyGrab = sameTeam // base setting
	bool classicRodeo = ClassicRodeo_IsEnabled()

	//if ( rodeoPilot.GetTeam() == rodeoTitan.GetTeam() )

	if ( classicRodeo ) // classic rodeo triggered!
	{
		waitthread ClassicRodeoThink( rodeoPilot, titanSoul, rodeoPackage )
		WaitForever()
	}

	#if MP
	if ( PlayerWantsToThrowNukeGrenade( rodeoPilot ) )
	{
		waitthread PlayerAppliesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )
		return
	}
	#endif

	if ( ShouldThrowGrenadeInHatch( rodeoPilot ) )
	{
		waitthread PlayerThrowsGrenadeInHatch( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage ) //This ends rodeo at the end of the sequence
	}
	else
	{
		waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage ) //This ends rodeo at the end of the sequence
	}

}

struct RodeoRiderSequenceStruct
{
	bool wasCloaked = false
	float cloakEndTime = 0.0
	string interiorSound = ""
	string exteriorSound = ""
}

void function DisableCloakBeforeRodeoSequence( entity rodeoPilot, RodeoRiderSequenceStruct dataStruct )
{
	if ( !IsCloaked( rodeoPilot ) )
		return

	dataStruct.wasCloaked = true
	dataStruct.cloakEndTime = rodeoPilot.GetCloakEndTime()
	DisableCloak( rodeoPilot, 0.0 )

}

void function RestoreCloakAfterRodeoSequence( entity rodeoPilot, RodeoRiderSequenceStruct dataStruct )
{
	if ( !IsAlive( rodeoPilot ) )
		return

	if ( !dataStruct.wasCloaked  )
		return

	Assert( dataStruct.cloakEndTime > 0.0 )

	float remainingCloakDuration = max( 0.0, dataStruct.cloakEndTime - Time() )
	if ( remainingCloakDuration > CLOAK_FADE_IN  ) //Has to be greater than 1.0 fade in duration, otherwise will cloak forever
		EnableCloak( rodeoPilot, remainingCloakDuration, CLOAK_FADE_IN )
}

void function PlayerRemovesBatteryPack( entity rodeoPilot, entity rodeoTitan, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	if( ClassicRodeo_IsEnabled() )
	{
		if( ClassicRodeo_IsPlayerRemovingBatteryPack( rodeoPilot ) ) // defensive fix
			return
		ViewConeZeroInstant( rodeoPilot ) // player try to look around will mess up animEvents!
		rodeoPilot.Anim_Stop() // clean up last?
		rodeoPilot.s.removingBatteryPack = true
		rodeoPilot.EndSignal( "RodeoOver" ) // this is also needed to let player jump off rodeo any time
		//titanSoul.EndSignal( "ApplyBatteryToTitan" ) // modified condition, player applied a new battery to their titan
		rodeoPilot.Signal( "PlayerRemovesBatteryPack" ) // defensive fix
		rodeoPilot.EndSignal( "PlayerRemovesBatteryPack" )
	}

	string titanType = GetSoulTitanSubClass( titanSoul )

	RodeoRiderSequenceStruct dataStruct
	dataStruct.interiorSound = GetAudioFromAlias( titanType, "rodeo_battery_steal_1p" )
	dataStruct.exteriorSound = GetAudioFromAlias( titanType, "rodeo_battery_steal_3p" )
	//DisableCloakBeforeRodeoSequence( rodeoPilot, dataStruct )

	entity tempBattery3p
	tempBattery3p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery3p.SetParent( rodeoPilot, "R_HAND", false, 0.0 )
	tempBattery3p.RemoveFromSpatialPartition()
	tempBattery3p.Hide()

	entity pilotFirstPersonProxy = rodeoPilot.GetFirstPersonProxy()
	entity tempBattery1p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery1p.SetParent( pilotFirstPersonProxy, "R_HAND", false, 0.0 )
	tempBattery1p.RemoveFromSpatialPartition()
	tempBattery1p.Hide()

	rodeoPilot.p.rodeoAnimTempProps.append( tempBattery1p )
	rodeoPilot.p.rodeoAnimTempProps.append( tempBattery3p )

	AddAnimEvent( rodeoPilot, "rodeo_battery_show", RodeoBatteryRemoval_ShowBattery ) //Consider adding this in add player
	AddAnimEvent( rodeoPilot, "rodeo_battery_rip", RodeoBatteryRemoval )
	AddAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning", RodeoBatteryStealthMovementWarning )
	thread MonitorRodeoPastPointOfNoReturn( rodeoPilot, titanSoul )

	OnThreadEnd(
		function() : ( rodeoPilot, titanSoul, titanType, dataStruct )
		{
			//print( "PlayerRemovesBatteryPack(): running OnThreadEnd()" )

			if ( IsValid( titanSoul ) )
			{
				entity rodeoPanel = titanSoul.soul.batteryContainer
				if ( IsValid( rodeoPanel ) )
				{
					titanSoul.soul.batteryContainerBeingUsed = false

					if ( titanSoul.soul.batteryContainerPastPointOfNoReturn )
					{
						if( !ClassicRodeo_IsEnabled() || ClassicRodeo_ShouldMoveUpBattery( titanSoul ) ) // check for classic rodeo panel, always move if vanilla rodeo
							rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )

					}
					else
					{
						if( !ClassicRodeo_IsEnabled() || ClassicRodeo_ShouldMoveUpBattery( titanSoul ) ) // check for classic rodeo panel, always move if vanilla rodeo
						{
							rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up_idle" ) )
							rodeoPanel.Anim_DisableSequenceTransition() //Snap into place instead of blending
						}
					}

					titanSoul.soul.batteryContainerPastPointOfNoReturn = false
				}
			}


			if ( !IsValid( rodeoPilot ) )
				return

			// modified playerSetting for classic rodeo
			rodeoPilot.s.removingBatteryPack = false

			if (  HasAnimEvent( rodeoPilot, "rodeo_battery_rip" )  )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_rip" )

			if (  HasAnimEvent( rodeoPilot, "rodeo_battery_show" )  )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_show" )

			if ( HasAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning" ) )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning" )

			ClearRodeoAnimTempProps( rodeoPilot )

			StopSoundOnEntity( rodeoPilot, dataStruct.interiorSound )
			StopSoundOnEntity( rodeoPilot, dataStruct.exteriorSound )

			//RestoreCloakAfterRodeoSequence( rodeoPilot, dataStruct )
		}
	)

	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	string batteryRipAnim = GetAnimFromAlias( titanType, "pt_rodeo_back_right_hijack_battery"  ) // default, old style
	//printt( "Battery Rip Anim: " + batteryRipAnim )
	sequence.thirdPersonAnim = batteryRipAnim
	sequence.firstPersonAnim = GetAnimFromAlias( titanType, "ptpov_rodeo_back_right_hijack_battery" )

	if ( GetBugReproNum() == 112023 )
		rodeoTitan.SnapEyeAngles( < 89, 100.02, 0 > )

	EmitDifferentSoundsOnEntityForPlayerAndWorld( dataStruct.interiorSound, dataStruct.exteriorSound, rodeoPilot, rodeoTitan ) //Play sound on rodeoPilot instead of panel
	FirstPersonSequence( sequence, rodeoPilot, rodeoTitan )
	ChangeTitanTitleWhenBatteryMoved( rodeoTitan, false )
}

void function ChangeTitanTitleWhenBatteryMoved( entity titan, bool battery )
{
	if( !IsValid( titan ) )
		return
	entity soul = titan.GetTitanSoul()
	if( !IsValid( soul ) )
		return
	if( !( "titanTitle" in soul.s ) )
		return
	if( battery )
	{
		titan.SetTitle( soul.s.titanTitle )
		return
	}
	titan.SetTitle( soul.s.titanTitle + " - 反應爐外漏" )
}

void function MonitorRodeoPastPointOfNoReturn( entity rodeoPilot, entity titanSoul )
{
	titanSoul.Signal( "MonitorRodeoPastPointOfNoReturn" )
	titanSoul.EndSignal( "MonitorRodeoPastPointOfNoReturn" )
	rodeoPilot.EndSignal( "RodeoOver" )

	titanSoul.soul.batteryContainerPastPointOfNoReturn = false

	rodeoPilot.WaitSignal( "RodeoPointOfNoReturn" )
	titanSoul.soul.batteryContainerPastPointOfNoReturn = true
}

void function PlayerThrowsGrenadeInHatch( entity rodeoPilot, entity rodeoTitan, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	if( ClassicRodeo_IsEnabled() )
	{
		if( ClassicRodeo_IsPlayerThrowingGrenadeInHatch( rodeoPilot ) ) // defensive fix
			return
		rodeoPilot.s.throwingGrenadeInHatch = true
		ViewConeZeroInstant( rodeoPilot ) // player try to look around will mess up animEvents!
		rodeoPilot.Anim_Stop() // clean up last?
		rodeoPilot.EndSignal( "RodeoOver" ) // this is also needed to let player jump off rodeo any time
		rodeoPilot.EndSignal( "RodeoBatteryRemoval" ) // check for classic rodeo! end animation after throwing one grenade
		titanSoul.EndSignal( "ApplyBatteryToTitan" ) // modified condition, player applied a new battery to their titan
		rodeoPilot.Signal( "PlayerThrowsGrenadeInHatch" ) // stop player last thread, prevent dealing damage multiple times
		rodeoPilot.EndSignal( "PlayerThrowsGrenadeInHatch" )
	}

	AddAnimEvent( rodeoPilot, "rodeo_battery_grenade_damage", RodeoBatteryRemoval )
	AddAnimEvent( rodeoPilot, "rodeo_battery_grenade_show", RodeoBatteryGrenadeShow )
	AddAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning", RodeoBatteryStealthMovementWarning )

	entity grenade3p = CreatePropDynamic( GRENADE_MODEL )
	grenade3p.SetParent( rodeoPilot, "PROPGUN", false, 0.0 )
	grenade3p.RemoveFromSpatialPartition()
	grenade3p.Hide()

	entity grenade1p = CreatePropDynamic( GRENADE_MODEL )
	grenade1p.SetParent( rodeoPilot.GetFirstPersonProxy(), "PROPGUN", false, 0.0 )
	grenade1p.RemoveFromSpatialPartition()
	grenade1p.Hide()

	rodeoPilot.p.rodeoAnimTempProps.append( grenade3p )
	rodeoPilot.p.rodeoAnimTempProps.append( grenade1p )

	string titanType = GetSoulTitanSubClass( titanSoul )
	RodeoRiderSequenceStruct dataStruct
	dataStruct.interiorSound = GetAudioFromAlias( titanType, "rodeo_grenade_1p" )
	dataStruct.exteriorSound = GetAudioFromAlias( titanType, "rodeo_grenade_3p" )
	DisableCloakBeforeRodeoSequence( rodeoPilot, dataStruct )

	OnThreadEnd(
		function() : ( rodeoPilot, titanSoul, titanType, dataStruct )
		{
			//print( "PlayerThrowsGrenadeInHatch(): running OnThreadEnd()" )

			if ( IsValid( titanSoul ) )
			{
				titanSoul.soul.batteryContainerBeingUsed = false
				if( !ClassicRodeo_IsEnabled() || ClassicRodeo_ShouldMoveUpBattery( titanSoul ) ) // check for classic rodeo panel, always move if vanilla rodeo
					titanSoul.soul.batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
			}

			if ( !IsValid( rodeoPilot ) )
				return

			// modified playerSetting for classicRodeo
			rodeoPilot.s.throwingGrenadeInHatch = false

			if (  HasAnimEvent( rodeoPilot, "rodeo_battery_grenade_damage" )  )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_grenade_damage" )

			if (  HasAnimEvent( rodeoPilot, "rodeo_battery_grenade_show" )  )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_grenade_show" )

			if ( HasAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning" ) )
				DeleteAnimEvent( rodeoPilot, "rodeo_battery_stealth_movement_warning" )

			ClearRodeoAnimTempProps( rodeoPilot )

			StopSoundOnEntity( rodeoPilot, dataStruct.interiorSound )
			StopSoundOnEntity( rodeoPilot, dataStruct.exteriorSound )

			RestoreCloakAfterRodeoSequence( rodeoPilot, dataStruct )
		}
	)

	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	//string batteryRipAnim = GetAnimFromAlias( titanSubClass, "pt_rodeo_back_right_hijack_battery"  ) // Do this once the animations aren't named the same/enabled for different titans
	//printt( "Battery Rip Anim: " + batteryRipAnim )
	sequence.thirdPersonAnim = GetAnimFromAlias( titanType, "pt_rodeo_grenade" )
	sequence.firstPersonAnim = GetAnimFromAlias( titanType, "ptpov_rodeo_grenade" )

	EmitDifferentSoundsOnEntityForPlayerAndWorld( dataStruct.interiorSound, dataStruct.exteriorSound, rodeoPilot, rodeoTitan ) //Play sound on rodeoPilot instead of panel

	waitthread FirstPersonSequence( sequence, rodeoPilot, rodeoTitan )
}

void function PlayerAppliesBatteryPack_DelayedClearSyncedEntity( entity rodeoPilot, entity titanSoul )
{
	if ( !IsValid( rodeoPilot ) )
	{
		return
	}

	if ( !IsValid( titanSoul ) )
	{
		return
	}

	if ( titanSoul.soul.batteryContainerBeingUsed )
	{
		return
	}

	rodeoPilot.SetSyncedEntity( null )
}

void function PlayerAppliesBatteryPack( entity rodeoPilot, entity rodeoTitan, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	if( ClassicRodeo_IsEnabled() ) // special checks!
	{
		if( ClassicRodeo_IsPlayerApplyingBatteryPack( rodeoPilot ) ) // defensive fix
			return
		ViewConeZeroInstant( rodeoPilot ) // player try to look around will mess up animEvents!
		rodeoPilot.Anim_Stop() // clean up last?
		rodeoPilot.s.applyingBatteryPack = true
		rodeoPilot.EndSignal( "RodeoOver" ) // this is also needed to let player jump off rodeo any time
		rodeoPilot.Signal( "PlayerAppliesBatteryPack" ) // defensive fix
		rodeoPilot.EndSignal( "PlayerAppliesBatteryPack" )
	}

	entity battery

	#if MP
	bool nukeVersion = false
	if ( PlayerWantsToThrowNukeGrenade( rodeoPilot ) )
	{
		nukeVersion = true
		// battery = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	}
	else
	{

		battery = GetBatteryOnBack( rodeoPilot )
		battery.Hide() //Hide it because the animation has a battery model already
	}
	#else
	battery = GetBatteryOnBack( rodeoPilot )
	battery.Hide() //Hide it because the animation has a battery model already
	#endif

	entity rodeoPanel = titanSoul.soul.batteryContainer

	entity tempBattery3p
	tempBattery3p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery3p.SetParent( rodeoPilot, "R_HAND", false, 0.0 )
	tempBattery3p.RemoveFromSpatialPartition()

	entity tempBattery1p
	tempBattery1p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery1p.SetParent( rodeoPilot.GetFirstPersonProxy(), "R_HAND", false, 0.0 )
	tempBattery1p.RemoveFromSpatialPartition()

	#if MP
		if ( nukeVersion )
			tempBattery1p.SetSkin( 1 )
	#endif
	if ( IsAmpedBattery( battery ) )
	{
		tempBattery1p.SetSkin( 2 )
		tempBattery3p.SetSkin( 2 )
	}

	if( battery.GetSkin() == 1 )
	{
		tempBattery1p.SetSkin( 1 )
	}

	rodeoPilot.p.rodeoAnimTempProps.append( tempBattery3p )
	rodeoPilot.p.rodeoAnimTempProps.append( tempBattery1p )

	string soundAlias = "rodeo_battery_return"
	string animAlias = "rodeo_back_right_apply_battery"

	#if MP
	if ( nukeVersion )
	{
		soundAlias = "nuke_rodeo_battery_return"
		animAlias = "nuke_rodeo_back_right_apply_battery"
	}
	#endif

	string titanType = GetSoulTitanSubClass( titanSoul )
	RodeoRiderSequenceStruct dataStruct
	dataStruct.interiorSound = GetAudioFromAlias( titanType, soundAlias + "_1p" )
	dataStruct.exteriorSound = GetAudioFromAlias( titanType, soundAlias + "_3p" )
	//DisableCloakBeforeRodeoSequence( rodeoPilot, dataStruct )

	OnThreadEnd(
	function() : ( battery, titanSoul, titanType, rodeoPilot, dataStruct )
		{
			//print( "PlayerAppliesBatteryPack(): running OnThreadEnd()" )

			if ( IsValid( battery ) )
				battery.Show()

			entity batteryContainer = titanSoul.soul.batteryContainer
			if ( IsValid( batteryContainer ) )
			{
				if ( IsValid( battery ) )
				{
					if( !ClassicRodeo_IsEnabled() || ClassicRodeo_ShouldMoveUpBattery( titanSoul ) ) // check for classic rodeo panel, always move if vanilla rodeo
						batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
				}
				else
				{
					if( !ClassicRodeo_IsEnabled() || ClassicRodeo_ShouldMoveUpBattery( titanSoul ) ) // check for classic rodeo panel, always move if vanilla rodeo
					{
						batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up_idle" ) )
						batteryContainer.Anim_DisableSequenceTransition()
					}

				}

				if ( IsValid( rodeoPilot ) && IsValid( titanSoul ) )
				{
					delaythread( 0.1 ) PlayerAppliesBatteryPack_DelayedClearSyncedEntity( rodeoPilot, titanSoul )
				}

				titanSoul.soul.batteryContainerBeingUsed = false
			}


			if ( !IsValid( rodeoPilot ) )
				return

			// classic rodeo clean up
			rodeoPilot.s.applyingBatteryPack = false

			ClearRodeoAnimTempProps( rodeoPilot )

			StopSoundOnEntity( rodeoPilot, dataStruct.interiorSound )
			StopSoundOnEntity( rodeoPilot, dataStruct.exteriorSound )

			//RestoreCloakAfterRodeoSequence( rodeoPilot, dataStruct )
		}
	)

	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	string batteryApplicationAnim = GetAnimFromAlias( titanType, "pt_" + animAlias )  // default, old style
	//printt( "Battery Application Anim: " + batteryApplicationAnim )
	sequence.thirdPersonAnim 		= batteryApplicationAnim
	sequence.firstPersonAnim 		= GetAnimFromAlias( titanType, "ptpov_" + animAlias )

	EmitDifferentSoundsOnEntityForPlayerAndWorld( dataStruct.interiorSound, dataStruct.exteriorSound, rodeoPilot, rodeoTitan ) //Play sound on rodeoPilot instead of panel

	entity batteryContainer = titanSoul.soul.batteryContainer
	if ( batteryContainer )
	{
		rodeoPilot.SetSyncedEntity( batteryContainer )
	}

	waitthread FirstPersonSequence( sequence, rodeoPilot, rodeoTitan )

	//Time passed, need to update titan reference
	rodeoTitan = titanSoul.GetTitan()
	Assert( IsAlive( rodeoTitan ) )


	#if MP
		if ( nukeVersion )
			thread RodeoForceNuke( rodeoPilot )
		else
			Rodeo_PilotAddsBatteryToFriendlyTitan( rodeoPilot, rodeoTitan )
	#else
		Rodeo_PilotAddsBatteryToFriendlyTitan( rodeoPilot, rodeoTitan )
	#endif

	ChangeTitanTitleWhenBatteryMoved( rodeoTitan, true )
}

void function ClearRodeoAnimTempProps( entity player )
{
	foreach( tempProp in player.p.rodeoAnimTempProps )
	{
		if ( IsValid( tempProp ) )
			tempProp.Destroy()
		}

	player.p.rodeoAnimTempProps.clear()
}

void function RodeoBatteryPackRemovalDamage( entity attacker, entity victim, entity victimTitanSoul )
{
	victimTitanSoul.e.lastRodeoAttacker = attacker

	int damageAmount = GetSegmentHealthForTitan( victim )

	bool isGrenadeDamage = PlayerHasBattery( attacker )
	bool classicRodeo = ClassicRodeo_IsEnabled()
	if( classicRodeo && ClassicRodeo_GetSoulBatteryCount( victimTitanSoul ) >= 1 )
		isGrenadeDamage = false // check for classicRodeo conditions: if victimTitan has battery left, then it must be a batteryRemoval rodeo

	bool damageNerf = isGrenadeDamage
	if( file.batteryRemovalDamageAmped ) // classic rodeo grenade is amped if file.batteryRemovalDamageAmped
		damageNerf = false

	if ( damageNerf ) //i.e. you are throwing a grenade
		damageAmount /= 2

	SetSoulBatteryCount( victimTitanSoul, GetSoulBatteryCount( victimTitanSoul ) - 1 )

	int damageScriptType = damageTypes.rodeoBatteryRemoval

	/*if ( GetDoomedState( victim ) )
	{
		damageAmount = victim.GetHealth() + 1
	}
	else */
	if ( IsHardcoreGameMode() )
	{
		damageAmount = victim.GetHealth()
	}

	table damageTable =
	{
		scriptType = damageScriptType
		forceKill = false
		damageSourceId = eDamageSourceId.rodeo_battery_removal
		origin = victim.GetOrigin()
		hitbox = 2
	}

	//print( !isGrenadeDamage && ClassicRodeo_IsEnabled() )
	/*if( !isGrenadeDamage && classicRodeo ) // confirm it's batteryStyle damage
	{
		// take additional damage to remove all shields. victim.GetShieldHealth() won't work for titans! have to track soul's shield amount
		if( file.batteryRemovalDamageAmped ) // if damageAmped, will also remove all shields from victim, means it will always deal 2500 damage to titan's health
		{
			victim.TakeDamage( victimTitanSoul.GetShieldHealth(), attacker, attacker, damageTable )
			//victimTitanSoul.SetShieldHealth( 0 ) // this won't give player additional titanMeters, maybe better?
		}
		entity coreWeapon = victim.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		if( IsValid( coreWeapon ) )
		{
			if( !CheckCoreAvailable( coreWeapon ) )
			{
				// also remove some of core meter if core not avaliable yet
				float currentCoreMeter = SoulTitanCore_GetNextAvailableTime( victimTitanSoul )
				float goalCoreMeter = max( 0, currentCoreMeter - ( GetCurrentPlaylistVarFloat( "battery_core_frac", 0.2 ) * GetCurrentPlaylistVarFloat( "earn_meter_titan_multiplier", 1.0 ) ) )
				SoulTitanCore_SetNextAvailableTime( victimTitanSoul, goalCoreMeter )
			}
		}
	}
	if( classicRodeo ) // classic rodeo behavior: bypass shields, works both for batteryRemoval and grenadeThrow
		damageTable.scriptType = damageScriptType | DF_BYPASS_SHIELD*/
	//print( "RodeoBatteryRemoval dealing damage!" )
	victim.TakeDamage( damageAmount, attacker, attacker, damageTable )
	if ( victim.IsNPC() )
		victim.SetEnemyLKP( attacker, attacker.GetOrigin() )

	entity batteryContainer = victimTitanSoul.soul.batteryContainer
	int hatchAttachmentIndex = batteryContainer.LookupAttachment( "REF" )

	TitanLoseSegementFX( victim, attacker, victim.GetAttachmentOrigin( hatchAttachmentIndex ) )

	if ( IsSingleplayer() && attacker.IsPlayer() )
	{
		UnlockAchievement( attacker, achievements.RODEO )
	}
}

void function Rodeo_DropAllBatteriesOnDeath( entity player, entity attacker, var damageInfo )
{
	Rodeo_DropAllBatteries( player )
}

void function Rodeo_ApplyAllBatteriesOnEmbark( entity player, entity titan )
{
	thread Rodeo_ApplyAllBatteriesOnEmbark_Thread( player, titan )
}

void function Rodeo_ApplyAllBatteriesOnEmbark_Thread( entity player, entity titan )
{
	player.EndSignal( "OnDeath" )

	if ( !PlayerHasBattery( player ) )
		return

	entity soul = player.GetTitanSoul()
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnTitanDeath" )

	table<string,bool> e
	e[ "hadAmped" ] <- false

	while ( GetPlayerBatteryCount( player ) > 0 )
	{
		thread Rodeo_ApplyBatteryDelayed( player, e )
	}

	wait 0.4

	MessagePlayerGivingBatteryToTitan( player, player, eEventNotifications.Rodeo_YouEmbarkedWithABattery, -1, e[ "hadAmped" ] )
}

void function Rodeo_ApplyBatteryDelayed( entity player, table<string,bool> e )
{
	entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
	e[ "hadAmped" ] = e[ "hadAmped" ] || IsAmpedBattery( battery )
	int skin = battery.GetSkin()
	battery.Destroy()

	entity dummyBattery = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	dummyBattery.SetSkin( skin )
	dummyBattery.Hide()

	entity soul = player.GetTitanSoul()

	OnThreadEnd(
		function() : ( dummyBattery ) {
			if ( IsValid( dummyBattery ) )
				dummyBattery.Destroy()
		}
	)

	if ( !IsValid( soul ) )
		return

	dummyBattery.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnTitanDeath" )

	wait 0.4 // delay so that it applies the battery when the player is inside the titan, so he can see the health bar change

	if ( IsValid( soul.GetTitan() ) )
		Rodeo_ApplyBatteryToTitan( dummyBattery, soul.GetTitan(), false )
}

void function Rodeo_GiveExecutingTitanABattery( entity attacker )
{
	Rodeo_ApplyBatteryToTitan( null, attacker, false )
	MessagePlayerGivingBatteryToTitan( attacker, attacker, eEventNotifications.Rodeo_TitanPickedUpBattery, -1, false )
}

void function Rodeo_GiveBatteryToPlayer( entity player )
{
	if ( PlayerHasMaxBatteryCount( player ) )
		return

	entity battery = Rodeo_CreateBatteryPack()
	Rodeo_OnTouchBatteryPack_Internal( player,  battery ) //Just setting the origin to the player's origin also works, but it will parent weirdly to a pilot's back. probably because we end up doing 2 SetOrigins in the same frame
}

void function Burnmeter_AmpedBattery( entity player )
{
	#if MP
	entity battery = Rodeo_CreateBatteryPack()
	int random = RandomInt( 3 ) == 0 ? 0 : 2
	if ( !PlayerHasMaxBatteryCount( player ) )
	{
		Rodeo_OnTouchBatteryPack_Internal( player,  battery ) //Just setting the origin to the player's origin also works, but it will parent weirdly to a pilot's back. probably because we end up doing 2 SetOrigins in the same frame

		entity battery = GetBatteryOnBack( player )

		if ( battery == null ) // not ideal but at least the game won't crash
			return

		battery.SetSkin( random ) // yellow - CHANGE SKIN TO ORANGE someday
		Battery_StartFX( battery )

		if( battery.GetSkin() == 2 && IsValid( player ) )
			SendHudMessage(player, "获得黄电池！",  -1, 0.4, 255, 255, 0, 0, 0.15, 4, 1);
		else if( battery.GetSkin() == 0 && IsValid( player ) )
			SendHudMessage(player, "获得绿电池！",  -1, 0.4, 0, 255, 0, 0, 0.15, 4, 1);
	}
	else
	{
		//Based off ThrowBattery
		vector ornull thrownSpot = CalculateSpotForThrownBattery( player, battery )

		if ( thrownSpot == null )
			thrownSpot = player.GetOrigin()

		expect vector( thrownSpot )

		vector viewVector = player.GetViewVector()

		//printt( "viewVector: " + viewVector )
		//battery.SetPhysics( MOVETYPE_FLYGRAVITY )

		battery.SetParent( player ) //HACK: Clear Ground Entity of battery. Not really sure why this is needed
		battery.ClearParent()

		battery.SetAngles( < 0, 0, 0 > )
		battery.SetOrigin( thrownSpot )

		vector playerVel = player.GetVelocity()
		vector verticalAdjustment = < 0, 0, 0 >
		if ( playerVel.z == 0 )
			verticalAdjustment = < 0, 0, 100 >

		vector batteryVel = playerVel + viewVector * 50 + verticalAdjustment
		battery.SetVelocity( batteryVel )

		if ( battery == null ) // not ideal but at least the game won't crash
			return

		battery.SetSkin( random ) // yellow - CHANGE SKIN TO ORANGE someday
		Battery_StartFX( battery )

		if( battery.GetSkin() == 2 && IsValid( player ) )
			SendHudMessage(player, "获得黄电池！",  -1, 0.4, 255, 255, 0, 0, 0.15, 4, 1);
		else if( battery.GetSkin() == 0 && IsValid( player ) )
			SendHudMessage(player, "获得绿电池！",  -1, 0.4, 0, 255, 0, 0, 0.15, 4, 1);
	}
	#endif
}

void function Burnmeter_EmergencyBattery( entity player )
{
	entity battery = Rodeo_CreateBatteryPack()
	if ( !PlayerHasMaxBatteryCount( player ) )
	{
		Rodeo_OnTouchBatteryPack_Internal( player,  battery ) //Just setting the origin to the player's origin also works, but it will parent weirdly to a pilot's back. probably because we end up doing 2 SetOrigins in the same frame
		return
	}
	else
	{
		//Based off ThrowBattery
		vector ornull thrownSpot = CalculateSpotForThrownBattery( player, battery )

		if ( thrownSpot == null )
			thrownSpot = player.GetOrigin()

		expect vector( thrownSpot )

		vector viewVector = player.GetViewVector()

		//printt( "viewVector: " + viewVector )
		//battery.SetPhysics( MOVETYPE_FLYGRAVITY )

		battery.SetParent( player ) //HACK: Clear Ground Entity of battery. Not really sure why this is needed
		battery.ClearParent()

		battery.SetAngles( < 0, 0, 0 > )
		battery.SetOrigin( thrownSpot )

		vector playerVel = player.GetVelocity()
		vector verticalAdjustment = < 0, 0, 0 >
		if ( playerVel.z == 0 )
			verticalAdjustment = < 0, 0, 100 >

		vector batteryVel = playerVel + viewVector * 50 + verticalAdjustment
		battery.SetVelocity( batteryVel )

	}

}

entity function Rodeo_CreateBatteryPack( entity batteryOwner = null, bool isPickup = false, bool hideIcon = false ) //( entity titanStolenFrom = null )
{
	entity batteryPack = CreateEntity( "item_titan_battery" )
	batteryPack.SetValueForModelKey( RODEO_BATTERY_MODEL )
	batteryPack.kv.fadedist = 10000
	DispatchSpawn( batteryPack )
	batteryPack.SetModel( RODEO_BATTERY_MODEL )
	batteryPack.s.createTime <- Time()
	batteryPack.s.touchEnabledTime <- 0
	batteryPack.s.batteryCarriedStatusEffect <- 0

	batteryPack.Minimap_SetAlignUpright( true )
	batteryPack.Minimap_SetZOrder( MINIMAP_Z_OBJECT )

	if( hideIcon || file.alwaysHideBatteryIcons )
	{
		batteryPack.s.hideIcon <- true
		batteryPack.Minimap_Hide( TEAM_MILITIA, null )
		batteryPack.Minimap_Hide( TEAM_IMC, null )
		if( IsFFAGame() ) // hide for ffa
		{
			for( int i = 0; i <= 30; i++ ) // ttf2 is up to 30 teams
				batteryPack.Minimap_Hide( i, null )
		}
	}
	else // for nessie batteries
	{
		batteryPack.s.hideIcon <- false
		batteryPack.Minimap_SetClampToEdge( false )
		batteryPack.Minimap_AlwaysShow( TEAM_MILITIA, null )
		batteryPack.Minimap_AlwaysShow( TEAM_IMC, null )
	}
	if( file.shouldRandomBattery )
		batteryPack.SetSkin( RandomInt(3) )
	Battery_StartFX( batteryPack )

	array<entity> batteryArray = GetEntArrayByClass_Expensive( "item_titan_battery" )
	// fix for nessie
	if( batteryArray.len() > file.worldBatteryMaxCount )
	{
		int oldest = -1
		var oldestTime = -1
		for( int i = batteryArray.len() - 1; i > 0; i-- )
		{
			if( batteryArray[i].GetParent() ) // assuming this is a battery carried by players
				continue
			if( !( "spawnTime" in batteryArray[i] ) )
			{
				if( oldest == -1 )
					oldest = i
				continue
			}
			if( batteryArray[i].s.spawnTime < oldestTime )
			{
				oldestTime = batteryArray[i].s.spawnTime
				oldest = i
			}
		}
		if( oldest != -1 )
			batteryArray[ oldest ].Destroy()
	}

	if ( HAS_BATTERY_THIEF_ICON && batteryOwner != null )
	{
		Assert( batteryOwner.IsTitan() )
		if( batteryOwner.IsTitan() )
		{
			if ( batteryOwner.IsPlayer() )
			{
				batteryPack.SetBossPlayer( batteryOwner )
			}
			else
			{
				entity titanOwner = batteryOwner.GetBossPlayer()
				if ( IsValid( titanOwner ) )
					batteryPack.SetBossPlayer( titanOwner )
			}

			thread ClearBatteryBossPlayerAfterDelay( batteryPack, batteryOwner, RODEO_BATTERY_THIEF_ICON_DURATION )
		}
	}

	batteryPack.Highlight_SetInheritHighlight( true )

	// modified for nessy.gnut
	if( batteryOwner != null )
	{
		if( !IsPilot( batteryOwner ) )
			return batteryPack
		if ( !PlayerHasMaxBatteryCount( batteryOwner ) )
		{
			Rodeo_OnTouchBatteryPack_Internal( batteryOwner,  batteryPack ) //Just setting the origin to the player's origin also works, but it will parent weirdly to a pilot's back. probably because we end up doing 2 SetOrigins in the same frame
			return
		}
		else
		{
			//Based off ThrowBattery
			vector ornull thrownSpot = CalculateSpotForThrownBattery( batteryOwner, batteryPack )

			if ( thrownSpot == null )
				thrownSpot = batteryOwner.GetOrigin()

			expect vector( thrownSpot )

			vector viewVector = batteryOwner.GetViewVector()

			//printt( "viewVector: " + viewVector )
			//battery.SetPhysics( MOVETYPE_FLYGRAVITY )

			batteryPack.SetParent( batteryOwner ) //HACK: Clear Ground Entity of battery. Not really sure why this is needed
			batteryPack.ClearParent()

			batteryPack.SetAngles( < 0, 0, 0 > )
			batteryPack.SetOrigin( thrownSpot )

			vector playerVel = batteryOwner.GetVelocity()
			vector verticalAdjustment = < 0, 0, 0 >
			if ( playerVel.z == 0 )
				verticalAdjustment = < 0, 0, 100 >

			vector batteryVel = playerVel + viewVector * 50 + verticalAdjustment
			batteryPack.SetVelocity( batteryVel )

		}
	}

	//batteryPack.Highlight_SetInheritHighlight( true ) // moved up

	//if ( IsSingleplayer() )
	// so we can decide if battery can be pick up
	if( isPickup || file.batteryPickUp )
	{
		thread AttachTriggerToBattery( batteryPack )
		Highlight_SetNeutralHighlight( batteryPack, "health_pickup" )
	}

	//thread MonitorBatteryVelocity( batteryPack )
	return batteryPack
}

void function Battery_StartFX( entity battery )
{
	if( !IsValid( battery ) )
		return
	Battery_StopFX( battery ) //Clear existing fx first. Not quite ideal but easier to do this than have bug potential for FX to stack on top of each other.
	int attachID = battery.LookupAttachment( "fx_center" )

	asset fx = BATTERY_FX_FRIENDLY
	if ( battery.GetSkin() == 1 )
		return
	if ( battery.GetSkin() == 2 )
		fx = BATTERY_FX_AMPED

	battery.e.fxArray.append( StartParticleEffectOnEntity_ReturnEntity( battery, GetParticleSystemIndex( fx ), FX_PATTACH_POINT_FOLLOW, attachID ) )
}

void function Battery_StopFX( entity battery )
{
	foreach( fx in battery.e.fxArray )
	{
		EffectStop( fx )
	}

	battery.e.fxArray.clear()
}

void function Battery_StopFXAndHideIconForPlayer( entity player )
{
	if ( !PlayerHasBattery( player ) )
		return

	entity battery = GetBatteryOnBack( player )

	Battery_StopFX( battery )
	battery.ClearBossPlayer() //Boss player controls visibility of icon
}

void function AttachTriggerToBattery( entity batteryPack )
{
	entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( 100 )
	trigger.SetAboveHeight( 100 )
	trigger.SetBelowHeight( 100 ) //i.e. make the trigger a sphere as opposed to a cylinder
	trigger.SetOrigin( batteryPack.GetOrigin() )
	trigger.SetParent( batteryPack )
	trigger.kv.triggerFilterNpc = "none" // none
	trigger.kv.triggerFilterPlayer = "titan" // titan players only
	DispatchSpawn( trigger )
	trigger.SetEnterCallback( BatteryTrigger_ApplyBattery )
}

void function BatteryTrigger_ApplyBattery( entity trigger, entity player )
{
	if ( player.IsTitan() )
	{
		entity batteryPack = trigger.GetParent()

		if ( batteryPack != null )
		{
			// reworked
			//Rodeo_OnTouchBatteryPack( player, batteryPack )

			entity ownerTitan = batteryPack.GetBossPlayer()
			if( IsValid( ownerTitan ) && IsMultiplayer() )
			{
				if( player == ownerTitan ) // don't instant apply ripped battery to it's owner
					return
			}
			// so that player can pick up battery without having to disembark, and in mp they can eat any batteries on ground even if they're at max health
			if( !IsSingleplayer() || player.GetHealth() != player.GetMaxHealth() )
				Rodeo_OnTouchBatteryPack_Internal( player, batteryPack, true )
		}
	}
}

void function Rodeo_PilotPicksUpBattery_Silent( entity pilot, entity battery )
{
	Assert( battery.GetParent() == null )

	//nessie fix
	//if( !IsValid( battery ) )
	//	return

	if ( PlayerHasBattery( pilot ) )
	{
		battery.Destroy()
		battery = GetBatteryOnBack( pilot )
	}

	SetPlayerBatteryCount( pilot, GetPlayerBatteryCount( pilot ) + 1 )
	if ( GetPlayerBatteryCount( pilot ) == 1 )
	{
		battery.SetParent( pilot, "BATTERY_ATTACH" )
		battery.MarkAsNonMovingAttachment()
		battery.RemoveFromSpatialPartition()
		SetBatteryOnBack( pilot, battery )
	}

	if ( GAMETYPE == FREE_AGENCY && PlayerHasMaxBatteryCount( pilot ) && PlayerEarnMeter_GetOwnedFrac( pilot ) < 1.0 )
	{
		Rodeo_RemoveAllBatteriesOffPlayer( pilot )
		return
	}

	if ( battery.s.batteryCarriedStatusEffect == 0 )
		battery.s.batteryCarriedStatusEffect = StatusEffect_AddEndless( battery, eStatusEffect.battery_carried, 1.0 )
	battery.Minimap_Hide( TEAM_MILITIA, null )
	battery.Minimap_Hide( TEAM_IMC, null )
}

void function Rodeo_PilotPicksUpBattery( entity pilot, entity battery )
{
	Rodeo_PilotPicksUpBattery_Silent( pilot, battery )
	EmitSoundOnEntityOnlyToPlayer( pilot, pilot, PILOT_PICKS_UP_BATTERY_SOUND )
	// allows player throw battery in non-titan modes
	if( Riff_TitanAvailability() == eTitanAvailability.Never && file.canThrowBattery )
	{
		AddPlayerHeldButtonEventCallback( pilot, IN_USE, Rodeo_PilotThrowsBattery, RODEO_THROW_BATTERY_BUTTON_HOLD_TIME )
		//for controller players
		AddPlayerHeldButtonEventCallback( pilot, IN_USE_AND_RELOAD, Rodeo_PilotThrowsBattery, RODEO_THROW_BATTERY_BUTTON_HOLD_TIME * 2 )
	}
}

entity function Rodeo_TakeBatteryAwayFromPilot( entity pilot )
{
	SetPlayerBatteryCount( pilot, GetPlayerBatteryCount( pilot ) - 1 )

	// removing some of respawn's remaining code. "unreachable" and hardcodes never makes any sense
	entity battery = GetBatteryOnBack( pilot )
	// clear out exisiting battery network var
	SetBatteryOnBack( pilot, null ) //Defensive fix for 209362. Set it to null before doing any other actions on it which might cause execution to jump somewhere else. I think doing PutEntityInSafeSpot() might cause this?

	// nessie fix
	// sometimes battery can be invalid
	if( IsValid( battery ) )
	{
		battery.Minimap_AlwaysShow( TEAM_MILITIA, null )
		battery.Minimap_AlwaysShow( TEAM_IMC, null )

		battery.s.touchEnabledTime = Time() + 0.3

		Battery_StartFX( battery ) //Needed to properly restore effect when player is killed while cloaked and carrying a battery

		battery.Show()

		if ( battery.s.batteryCarriedStatusEffect > 0 )
		{
			StatusEffect_Stop( battery, battery.s.batteryCarriedStatusEffect )
			battery.s.batteryCarriedStatusEffect = 0
		}

		battery.ClearParent()
		battery.AddToSpatialPartition()
		battery.SetAngles( <0, 0, 0 > )
		battery.SetVelocity( < 0, 0, 1 > )
		PutEntityInSafeSpot( battery, pilot, null, pilot.GetOrigin(), battery.GetOrigin() ) //This might cause thread of execution to jump somewhere else, see 209362
	}

	return battery
}

void function Rodeo_PilotThrowsBattery( entity pilot )
{
	if ( pilot.ContextAction_IsActive() ) //Maybe letting you throw the battery out of the dropship might be cool?
		return

	entity battery = GetBatteryOnBack( pilot )

	// fix for nessie
	if( !IsValid( battery ) )
		return

	vector ornull thrownSpot = CalculateSpotForThrownBattery( pilot, battery )

	if ( thrownSpot == null )
	{
		EmitSoundOnEntityOnlyToPlayer( pilot, pilot, "CoOp_SentryGun_DeploymentDeniedBeep" )
		return
	}

	expect vector( thrownSpot )

	vector viewVector = pilot.GetViewVector()

	//printt( "viewVector: " + viewVector )

	entity playerBattery = Rodeo_TakeBatteryAwayFromPilot( pilot )
	Assert( playerBattery == battery )

	//battery.SetPhysics( MOVETYPE_FLYGRAVITY )

	battery.SetAngles( < 0, 0, 0 > )
	battery.SetOrigin( thrownSpot )
	vector pilotVel = pilot.GetVelocity()
	vector verticalAdjustment = < 0, 0, 0 >
	if ( pilotVel.z == 0 )
		verticalAdjustment = < 0, 0, 200 >

	vector batteryVel = pilotVel + viewVector * 300 + verticalAdjustment
	//printt( "batteryVel: " + batteryVel)
	//battery.SetVelocity( Vector( 0, 0, 0 ) )
	battery.SetVelocity( batteryVel )

	MessageToPlayer( pilot, eEventNotifications.Rodeo_YouDroppedABattery )
}

vector ornull function CalculateSpotForThrownBattery( entity pilot, entity battery )
{
	vector viewVector = pilot.GetViewVector()
	vector eyePos = pilot.EyePosition()
	vector batteryMins = battery.GetBoundingMins()
	vector batteryMaxs = battery.GetBoundingMaxs()
	vector endPos = eyePos + viewVector * 100
	TraceResults hullResult = TraceHull( eyePos, endPos, batteryMins, batteryMaxs, pilot, TRACE_MASK_SOLID | TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

	//PrintTraceResults( hullResult )

	if ( hullResult.startSolid )
		return null

	if ( hullResult.hitEnt == pilot )
		return null

	if ( hullResult.fraction == 1.0 )
		return endPos

	return hullResult.endPos
}

void function Rodeo_SetBatteryThrowEnabled( bool enabled )
{
	file.canThrowBattery = enabled
}

bool function IsBatteryThrowEnabled()
{
	return file.canThrowBattery
}

void function Rodeo_DropAllBatteries( entity player )
{
	if ( !PlayerHasBattery( player ) )
		return

	float batteryCount = float( GetPlayerBatteryCount( player ) - 1 ) // Floats instead of ints since we need decimal values for the math
	for ( float i = 1.0; GetPlayerBatteryCount( player ) > 1; i += 1.0 )
	{
		entity newBattery = Rodeo_CreateBatteryPack()
		newBattery.s.touchEnabledTime = Time() + 0.3
		vector direction = AnglesToForward( <0, i/batteryCount * 360.0, 0> )
		newBattery.SetOrigin( player.GetWorldSpaceCenter() + direction * 30 )
		newBattery.SetAngles( <0, 0, 0 > )
		vector baseVelocity = player.GetVelocity()
		baseVelocity.z = 0
		newBattery.SetVelocity( baseVelocity + direction * 100 + <0, 0, 1> )
		Rodeo_TakeBatteryAwayFromPilot( player )
	}

	entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
	Assert ( IsValid( battery ) )
}

void function Rodeo_RemoveBatteryOffPlayer( entity player ) //Meant to be used in prematch etc.
{
	if ( !PlayerHasBattery( player ) )
		return

	entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
	if ( IsValid( battery ) )
	{
		battery.Destroy()
	}
}

void function Rodeo_RemoveAllBatteriesOffPlayer( entity player ) //Meant to be used in prematch etc.
{
	if ( !PlayerHasBattery( player ) )
		return

	while ( GetPlayerBatteryCount( player ) > 0 )
	{
		Rodeo_RemoveBatteryOffPlayer( player )
	}
}

void function Rodeo_ApplyBatteryToTitan( entity battery, entity titan, bool shouldAddBatteryCount = true )
{
	entity soul = titan.GetTitanSoul()

	// classic rodeo battery!
	if( ClassicRodeo_IsEnabled() )
	{
		titan.Signal( "ApplyBatteryToTitan" )
		soul.Signal( "ApplyBatteryToTitan" ) // soul also signal this
		if( ClassicRodeo_GetSoulBatteryCount( soul ) == 0 ) // no battery before applying
			ClassicRodeo_TryMoveBatteryUp( soul )

		//bool shouldAddBatteryCount = true

		//print( "soul bossPlayerCheck: " + string( soul.GetBossPlayer() == titan ) )
		/*if( !file.ownerApplyBatteryAllowed && soul.GetBossPlayer() == titan ) // owner applying battery to it's titan is not allowed
			shouldAddBatteryCount = false*/
		if( file.batteryContainerOnlyProtectsOnce ) // only protects once
		{
			shouldAddBatteryCount = false
			if( soul.GetBossPlayer() != GetRodeoPilot( titan ) && ClassicRodeo_GetSoulBatteryCount( soul ) < 1 ) // rider applied battery but titan's only battery already been removed
				ClassicRodeo_TryMoveBatteryDown( soul ) // move down animation
		}

		if( shouldAddBatteryCount )
			ClassicRodeo_AddSoulBattery( soul )
	}

	if ( !IsValid( soul ) )
		return

	int healingAmount
	if ( IsSingleplayer() )
		healingAmount = 2000
	else
		healingAmount = GetSegmentHealthForTitan( titan )

	int health = titan.GetHealth()
	int maxHealth = titan.GetMaxHealth()

	SetSoulBatteryCount( soul, GetSoulBatteryCount( soul ) + 1 )

	int healthDifference = maxHealth - health

	if ( IsSingleplayer() )
	{
		if ( soul.IsDoomed() )
			UndoomTitan( titan, 1 )
		else if ( healthDifference >= healingAmount )
			titan.SetHealth( titan.GetHealth() + healingAmount )
		else
			titan.SetHealth( titan.GetMaxHealth() )

 		if ( GetHealthFrac( titan ) >= BATTERY_PICKUP_IGNORE_FRAC )
 		{
 			titan.SetHealth( titan.GetMaxHealth() )
 		}

 		titan.GetTitanSoul().nextRegenTime = Time()
	 	if ( healthDifference < healingAmount )
		{
			titan.GetTitanSoul().SetShieldHealth( healingAmount - healthDifference + titan.GetTitanSoul().GetShieldHealth() )
		}

		if ( GetShieldHealthFrac( titan ) >= BATTERY_PICKUP_IGNORE_FRAC )
 		{
 			titan.GetTitanSoul().SetShieldHealth( titan.GetTitanSoul().GetShieldHealthMax() )
 		}

	}
	else if ( IsMultiplayer() )
	{

		if( IsValid( battery ) && soul.IsDoomed() )
		{
			if( battery.GetSkin() == 2 )
			{
				UndoomTitan( titan, 1 )
				titan.SetHealth( 1 )
			}
		}
		if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_DOOM ) && soul.IsDoomed() )
		{
			UndoomTitan( titan, 1 )
			titan.SetHealth( 1 )
		}

		float coreFrac = 0.8
		float shieldFrac = GetCurrentPlaylistVarFloat( "battery_shield_frac", 1.0 )
		float ampedHealthSegmentFrac = 1.0
		float healthSegmentFrac = 1.0
		float RedBatteryHealthSegmentFrac = 0.5

		bool batteryIsAmped = IsAmpedBattery( battery )
		if( batteryIsAmped )
			coreFrac = 0.4
		if( IsValid( battery ) )
		{
			if( battery.GetSkin() == 1 )
			{
				coreFrac = 0.2
			}
		}
		if( battery == null && SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
			coreFrac = 0.2
		AddCreditToTitanCoreBuilder( titan, coreFrac ) //Always give core

		int shieldHealth = soul.GetShieldHealth()
		int shieldMaxHealth = soul.GetShieldHealthMax()

		int shieldDifference = shieldMaxHealth - shieldHealth

		float frac = batteryIsAmped ? ampedHealthSegmentFrac : healthSegmentFrac
		if( IsValid( battery ) )
		{
			if( battery.GetSkin() == 1 )
			{
				frac = RedBatteryHealthSegmentFrac
			}
		}
		if( battery == null && SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
			frac = RedBatteryHealthSegmentFrac

		int addHealth = int( healingAmount * frac )

		int totalHealth = minint( titan.GetMaxHealth(), titan.GetHealth() + addHealth )
		titan.SetHealth( totalHealth )
		soul.SetShieldHealth( soul.GetShieldHealthMax() )
	}

	if ( battery != null )
	{
		Assert( battery.GetParent() == null )
		battery.Destroy()
	}
}

// modified for nessie
bool function Rodeo_OnTouchBatteryPack( entity player, entity batteryPack )
{
	Rodeo_OnTouchBatteryPack_Internal( player, batteryPack )

	//Basically always return false since we don't want the battery pack to go away when being touched. ApplyBatteryToTitan() etc will deal with lifetime of battery
	return false
}

void function Rodeo_OnTouchBatteryPack_Internal( entity player, entity batteryPack, bool isPickup = false )
{
	float currentTime = Time()

	if ( currentTime < batteryPack.s.touchEnabledTime )
		return

	if ( !IsAlive( player ) )
		return

	if ( player.IsPhaseShifted() )
		return

	if ( IsValid( batteryPack.GetParent() ) )
		return

	if ( PlayerHasMaxBatteryCount( player ) )
	{
		if ( IsSingleplayer() )
		{
			MessageToPlayer( player, eEventNotifications.BATT_Full, batteryPack )
		}
		return
	}

	// why they can pick up so many batteries after clear? trying to fix nessie
	if( GetPlayerBatteryCount( player ) > PILOT_BATTERY_BUGGED_LIMIT )
	{
		while( GetPlayerBatteryCount( player ) > 0 )
		{
			entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
			if( IsValid( battery ) )
				battery.Destroy()
		}
		//SetPlayerBatteryCount( player, PILOT_BATTERY_BUGGED_LIMIT )
	}

	if ( player.IsTitan() )
	{
		//Try Titans not being able to pick up battery
		//if ( GetCurrentPlaylistVarInt( "rodeo_battery_disembark_to_pickup", 1 ) == 1 )
		if ( !isPickup ) // modified for BatteryTrigger_ApplyBattery()
		{
			if ( currentTime - player.p.batteryLastTouchedNotificationTime > 5.0 )
			{
				MessageToPlayer( player, eEventNotifications.Rodeo_DisembarkToPickUpBattery )
				player.p.batteryLastTouchedNotificationTime  = currentTime

			}
		}
		else
		{
			if ( IsSingleplayer() )
			{
				if ( player.GetHealth() >= player.GetMaxHealth() * BATTERY_PICKUP_IGNORE_FRAC && player.GetTitanSoul().GetShieldHealth() >= player.GetTitanSoul().GetShieldHealthMax() * BATTERY_PICKUP_IGNORE_FRAC )
				{
					MessageToPlayer( player, eEventNotifications.BATT_HealthFull, batteryPack )
					return
				}
			}
			bool amped = IsAmpedBattery( batteryPack )

			Rodeo_ApplyBatteryToTitan( batteryPack, player, false )
			MessagePlayerGivingBatteryToTitan( player, player, eEventNotifications.Rodeo_TitanPickedUpBattery, -1, amped )
		}
		return
	}
	else
	{
		if ( IsCloaked( player ) )
			Battery_StopFX( batteryPack ) //Will be turned on again when player loses cloak

		Rodeo_PilotPicksUpBattery( player, batteryPack )
		AddPlayerScore( player, "PilotBatteryPickup", player )
//		MessageToPlayer( player, eEventNotifications.Rodeo_PilotPickedUpBattery )
		return
	}
}

void function Rodeo_PilotAddsBatteryToFriendlyTitan( entity rider, entity titan )
{
	if ( !titan.IsTitan() )
		return

	//if ( titan.GetTeam() != rider.GetTeam() )
	if ( titan.GetTeam() != rider.GetTeam() ) // allow applying to enemy titans if friendlyFireOn
		return

	if ( !PlayerHasBattery( rider ) )
		return

	entity battery = Rodeo_TakeBatteryAwayFromPilot( rider )
	bool amped = IsAmpedBattery( battery )

	if ( file.applyBatteryCallback != null )
		file.applyBatteryCallback( rider, titan, battery )

	Rodeo_ApplyBatteryToTitan( battery, titan ) //This destroys the battery

	AddPlayerScore( rider, "PilotBatteryApplied", rider )

	EmitSoundOnEntityOnlyToPlayer( rider, rider, PILOT_APPLIES_BATTERY_TO_TITAN_HEALTH_RESTORED_SOUND )

	if ( titan.IsPlayer() )
		MessagePlayerGivingBatteryToTitan( titan, rider, eEventNotifications.Rodeo_PilotAppliedBatteryToYou, eEventNotifications.Rodeo_YouAppliedBatteryToTitan, amped )
	else
		MessagePlayerGivingBatteryToTitan( titan, rider, eEventNotifications.Rodeo_PilotAppliedBatteryToYourPetTitan, eEventNotifications.Rodeo_YouAppliedBatteryToPetTitan, amped )
}

void function MessagePlayerGivingBatteryToTitan( entity receivingTitan, entity givingPlayer, int enumForRecevingHealth, int enumForGivingHealth, bool wasAmped )
{
	entity receivingPlayer = receivingTitan

	if ( !receivingTitan.IsPlayer() )
		receivingPlayer = receivingTitan.GetBossPlayer()

	if ( !IsValid( receivingPlayer ) )
		return

	MessageToPlayer( receivingPlayer, enumForRecevingHealth, givingPlayer, wasAmped )
	if ( givingPlayer != receivingPlayer )
		MessageToPlayer( givingPlayer, enumForGivingHealth, receivingTitan, wasAmped )
}

bool function IsTitanAtFullHealth( entity receivingTitan )
{
	if ( !receivingTitan.IsTitan() )
		return false

	return ( receivingTitan.GetHealth() == receivingTitan.GetMaxHealth() )
}

function DebugRodeoTimes()
{
	array<string> settings = [ "atlas", "ogre", "stryder" ]

	array< asset > models = [ $"models/Humans/imc_pilot/male_cq/imc_pilot_male_cq.mdl", $"models/humans/pilot/female_cq/pilot_female_cq.mdl" ]
	table times = {}

	array<string> rodeoAnims = [
			"pt_rodeo_move_back_entrance",
			"pt_rodeo_move_right_entrance",
			"pt_rodeo_move_front_entrance",
			"pt_rodeo_move_front_lower_entrance",
			"pt_rodeo_move_back_mid_entrance",
			"pt_rodeo_move_back_lower_entrance",
			"pt_rodeo_move_left_entrance"
			]

	foreach ( model in models )
	{
		times[ model ] <- []
		entity prop = CreatePropDynamic( model, Vector(0,0,0), Vector(0,0,0) )
		printt( "Human model: " + model )

		foreach ( setting in settings )
		{
			foreach ( alias in rodeoAnims )
			{
				string animation = GetAnimFromAlias( setting, alias )
		        float time = prop.GetSequenceDuration( animation )
				times[ model ].append( { time = time, animation = animation } )
		    }
		}

		prop.Kill_Deprecated_UseDestroyInstead()
	}

	printt( "Time comparison: " )
	bool wrong = false
	for ( int i = 0; i < times[ models[0] ].len(); i++ )
	{
		if ( times[models[0]][i].time == times[models[1]][i].time )
		{
			printt( "   MATCH: " + ( i + 1 ) + " times: 	" + times[models[0]][i].time + "	 	" + times[models[1]][i].time + " 	" + times[models[1]][i].animation )
		}
		else
		{
			printt( "MISMATCH: " + ( i + 1 ) + " times: 	" + times[models[0]][i].time + "		 " + times[models[1]][i].time + " 	" + times[models[1]][i].animation )
		}
		if ( ( i + 1 ) % rodeoAnims.len() == 0 )
			printt( " " )
	}
	Assert( !wrong, "Times did not match between male and female, see above" )
}

void function SetBatteryOnBack( entity player, entity battery )
{
	player.SetPlayerNetEnt( "batteryOnBack", battery )
}

bool function ClientCommand_RequestRodeoBattery( entity player, array<string> args )
{
	//PrintFunc()
	if ( !ShouldLetPlayerRequestBattery( player ) )
		return true

	player.SetPlayerNetTime( "requestRodeoBatteryLastUsedTime", Time() )

	foreach( friendlyPlayer in GetPlayerArrayOfTeam( player.GetTeam() ) )
	{
		if ( friendlyPlayer == player )
			continue

		if ( friendlyPlayer.IsTitan() )
			continue

		//Could check to see if players actually have a battery here, but that stops players from being told that they should pick up a battery for someone in need
		MessageToPlayer( friendlyPlayer, eEventNotifications.Rodeo_RequestBattery, player )
	}

	return true
}

bool function ClientCommand_OfferRodeoBattery( entity player, array<string> args )
{
	//PrintFunc()
	if ( args.len() != 1 )
		return true

	int friendlyTitanEntIndex = args[ 0 ].tointeger()

	if ( friendlyTitanEntIndex < 1 ) //Data sanitation. GetEntByIndex() will assert if passed a negative number. 0 is always world spawn, so the first valid argument is 1
		return true

	entity friendlyTitan = GetEntByIndex( friendlyTitanEntIndex )

	if ( !ShouldShowOfferRodeoBatteryHint( player, friendlyTitan ) )
		return true

	entity battery = GetBatteryOnBack( player )

	MessageToPlayer( friendlyTitan, eEventNotifications.Rodeo_FriendlyPickedUpBattery, player, battery.GetEncodedEHandle() )

	player.SetPlayerNetTime( "offerRodeoBatteryLastUsedTime", Time() )

	return true

}

void function PlayerRodeoViewCone( entity player, string rodeoTargetType )
{
	player.PlayerCone_FromAnim()
	player.GetFirstPersonProxy().HideFirstPersonProxy()
	OpenViewCone( player )
	player.PlayerCone_Disable()
	player.EnableWorldSpacePlayerEyeAngles()
}

void function OpenViewCone( entity player )
{
	player.PlayerCone_FromAnim()
	player.PlayerCone_SetMinYaw( -179 )
	player.PlayerCone_SetMaxYaw( 181 )
	player.PlayerCone_SetMinPitch( -60 )
	player.PlayerCone_SetMaxPitch( 60 )
}

bool function PilotCanApplyBattery( entity rodeoPilot, entity rodeoTitan )
{
	if ( !IsAlive( rodeoTitan ) )
		return false

	//if ( rodeoTitan.GetTeam() != rodeoPilot.GetTeam() )
	if ( rodeoTitan.GetTeam() != rodeoPilot.GetTeam() ) // allow applying battery to enemy if friendlyFireOn...
		return false

	if ( !PlayerHasBattery( rodeoPilot ) )
		return false

	entity titanSoul = rodeoTitan.GetTitanSoul()
	Assert( IsValid( titanSoul ) )

	string titanType = GetSoulTitanSubClass( titanSoul )

	return true
}

void function ClearBatteryBossPlayerAfterDelay( entity battery, entity titan, float delay )
{
	entity soul = titan.GetTitanSoul()

	if ( !IsValid( soul ) )
		return

	soul.EndSignal( "OnTitanDeath" ) //End signal on soul to properly handle pilot getting in/out of titan
	battery.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function() : ( battery  )
		{
			if ( IsValid( battery ) )
				battery.ClearBossPlayer()
		}
	)

	wait delay
}

const float BATTERY_USES_ATTACKER_ORIGIN_THRESHOLD = 500 * 500 //500 seems like a lot, but the Titan melee execution sequences can go pretty far

void function TitanDropsBatteryOnDeath( entity titan, var damageInfo ) //Todo: Might want to do something special for titan melee execution, so the attacker automatically gets a battery
{
	if ( !titan.IsTitan() )
		return

	entity battery = Rodeo_CreateBatteryPack()
	vector titanOrigin = titan.GetOrigin()
	battery.SetOrigin( titanOrigin )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	vector safeOrigin = titanOrigin
	vector attackerOrigin
	if ( IsValid( attacker ) )
	{
		vector attackerOrigin = attacker.GetOrigin()
		float distSqr = DistanceSqr( attackerOrigin, titanOrigin )
		//printt( "Distance sqr: " + distSqr  )
		if ( distSqr <= ( BATTERY_USES_ATTACKER_ORIGIN_THRESHOLD ) ) //
		{
			//printt( "Putting attackerOrigin as safeOrigin" )

			safeOrigin = attackerOrigin
		}
	}

	bool result = PutEntityInSafeSpot( battery, null, null, safeOrigin, titanOrigin )
	if ( !result )
	{
		battery.Destroy() //Can't put the battery anywhere safe, so just destroy it.
		//printt( "Destroy battery since we can't put it in a safe spot" )
	}
}

void function ShowRequestRodeoBatteryHint_OnDamage( entity playerTitan, var damageInfo )
{
	ShowRequestRodeoBatteryHint( playerTitan )
}

void function ShowRequestRodeoBatteryHint_OnPilotBecomesTitan( entity player, entity titan )
{
	//printt( "player health: " + player.GetHealth() )
	ShowRequestRodeoBatteryHint( player )
}

void function ShowRequestRodeoBatteryHint( entity playerTitan )
{
	//PrintFunc()
	if ( !ShouldLetPlayerRequestBattery( playerTitan ) )
		return

	float currentTime = Time()

	if ( playerTitan.p.rodeoRequestBatteryHintLastShownTime > 0.0 && currentTime < playerTitan.p.rodeoRequestBatteryHintLastShownTime + REQUEST_RODEO_BATTERY_HINT_COOLDOWN ) //Use a different cooldown for the hint as opposed to the ability
	{
		//printt( "Current time: " + currentTime + ", lastShownTime: " + playerTitan.p.rodeoRequestBatteryHintLastShownTime + ", cooldown: " + REQUEST_RODEO_BATTERY_HINT_COOLDOWN )
		return
	}

	int stringID = GetStringID( "#RODEO_REQUEST_BATTERY_HINT" )
	MessageToPlayer( playerTitan, eEventNotifications.Rodeo_ShowBatteryHint, null, stringID )

	playerTitan.p.rodeoRequestBatteryHintLastShownTime = currentTime
}

void function SetSoulBatteryCount( entity soul, int count )
{
	count = maxint( 0, count )

	soul.SetTitanSoulNetInt( "rodeoBatteryCount", count )
}

void function PilotBattery_SetMaxCount( int batteryCount )
{
	file.maxPilotBatteryCount = batteryCount
}

bool function PlayerHasMaxBatteryCount( entity player )
{
	if ( !PlayerHasBattery( player ) )
	{
		Assert( GetPlayerBatteryCount( player ) == 0 )
		return false
	}

	return GetPlayerBatteryCount( player ) == file.maxPilotBatteryCount
}

void function ThrowRiderOff( entity rider, entity titan, vector direction, bool adjustAirControl = true )
{
	if ( GetBugReproNum() == 112023 ) //Track down why eye angles of rider snaps violently when titan is looking downwards
	{
		thread AnglesDebug( rider )
	}

	rider.p.rodeoShouldAdjustJumpOffVelocity = false

	rider.Signal( "RodeoOver" )
	rider.ClearParent()

	#if DEV
		if ( GetDebugRodeoPrint() )
			printt( "Throw Rider off: origin before vertical adjustment: " + rider.GetOrigin() )
	#endif

	rider.SetOrigin( rider.GetOrigin() + Vector( 0, 0, 100 ) )

	#if DEV
		if ( GetDebugRodeoPrint() )
			printt( "Throw Rider off: origin after vertical adjustment: " + rider.GetOrigin() )
	#endif

	//printt( "Rider eye angles: " + rider.EyeAngles() + ", rider Angles: " + rider.GetAngles() + " titan eye Angles:" + titan.EyeAngles() )

	// Set it higher in SP so bosses less exploitable
	#if SP
		direction += Vector( 0, 0, SP_RODEO_BOOST )
	#endif

	rider.SetVelocity( direction )
	rider.JumpedOffRodeo()

	int attachIndex = titan.LookupAttachment( "hijack" ) //TODO: Hardcoded, no way to get rodeopackage.attachpoint easily at this point anymore!
	vector startPos = titan.GetAttachmentOrigin( attachIndex )

	//printt( "startPos of attachment: " + startPos )

	if ( !PlayerCanTeleportHere( rider, startPos, titan ) )
	{
		startPos = titan.GetOrigin()
		if ( !PlayerCanTeleportHere( rider, startPos, titan ) )
			startPos = rider.GetOrigin()
	}

	PutEntityInSafeSpot( rider, titan, null, startPos, rider.GetOrigin() )

	#if DEV
		if ( GetDebugRodeoPrint() )
			printt( "Throw Rider off: origin after PutEntityInSafeSpot: " + rider.GetOrigin() )
	#endif

	if ( adjustAirControl )
		thread PostRodeoAirControl( rider )
}

void function PostRodeoAirControl( entity player )
{
	player.Signal( "PostRodeoAirControl" )
	player.EndSignal( "PostRodeoAirControl" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( player )
		{
			RestorePlayerAirControl( player )
		}
	)

	const float POST_RODEO_AIR_CONTROL_DURATION = 0.75
	const float POST_RODEO_AIR_CONTROL_SCALE = 0.5
	const float POST_RODEO_AIR_CONTROL_JUMP_DELAY = 0.45

	// give the player time to be thrown in the proper direction before they get back double jump
	RemovePlayerAirControl( player )
	player.ConsumeDoubleJump()
	wait POST_RODEO_AIR_CONTROL_JUMP_DELAY
	player.TouchGround()

	float startTime = Time()
	while ( Time() - startTime < POST_RODEO_AIR_CONTROL_DURATION && !player.IsOnGround() && !player.IsWallRunning() && !player.IsWallHanging() )
	{
		float elapsedTime = Time() - startTime
		player.kv.airSpeed = player.GetPlayerSettingsField( "airSpeed" ) * POST_RODEO_AIR_CONTROL_SCALE * (1 - (elapsedTime / POST_RODEO_AIR_CONTROL_DURATION))
		player.kv.airAcceleration = player.GetPlayerSettingsField( "airAcceleration" ) * POST_RODEO_AIR_CONTROL_SCALE * (1 - (elapsedTime / POST_RODEO_AIR_CONTROL_DURATION))
		//printt( "scale", POST_RODEO_AIR_CONTROL_SCALE * (1 - (elapsedTime / POST_RODEO_AIR_CONTROL_DURATION)) )

		WaitFrame()
	}
}

void function AnglesDebug( rider )
{
	printt( "Begin Angles Debug, Rider eye angles: " + rider.EyeAngles() + ", rider Angles: " + rider.GetAngles() )
	while( !rider.IsOnGround() )
	{
		printt( "Rider eye angles: " + rider.EyeAngles() + ", rider Angles: " + rider.GetAngles() )
		WaitFrame()
	}

	printt( "End Angles Debug, Rider eye angles: " + rider.EyeAngles() + ", rider Angles: " + rider.GetAngles() )
}

void function SetPlayerBatteryCount( entity player, int count )
{
	Assert( count <= file.maxPilotBatteryCount )
	Assert( count >= 0 )
	player.SetPlayerNetInt( "batteryCount", count )
}

int function GetPlayerBatteryCount( entity player )
{
	return player.GetPlayerNetInt( "batteryCount" )
}

void function DisableBTRodeo( entity soul )
{
	string settings = GetSoulPlayerSettings( soul )
	var rodeoAllow = Dev_GetPlayerSettingByKeyField_Global( settings, "rodeo_allow" )

	if ( rodeoAllow == null )
		return

	if ( rodeoAllow == 0 )
	{
		soul.SetIsValidRodeoTarget( false )
	}
}
void function RemovePlayerAirControl( entity player ) //This function should really be in a server only SP & MP utility script file. No such file exists as of right now.
{
	Assert( player.IsPlayer() )
	player.kv.airSpeed = 0
	player.kv.airAcceleration = 0
}

void function RestorePlayerAirControl( entity player ) //This function should really be in a server only SP & MP utility script file. No such file exists as of right now.
{
	Assert( player.IsPlayer() )
	player.kv.airSpeed = player.GetPlayerSettingsField( "airSpeed" )
	player.kv.airAcceleration = player.GetPlayerSettingsField( "airAcceleration" )
}

bool function ShouldThrowGrenadeInHatch( entity rodeoPilot )
{
	bool batteryPullingDisabled = (GetCurrentPlaylistVarInt( "rodeo_battery_disable_pulls_from_titans", 0 ) == 1)
	if ( batteryPullingDisabled )
		return true

	#if MP
	if ( PlayerWantsToThrowNukeGrenade( rodeoPilot ) )
		return false
	#endif

	if ( PlayerHasBattery( rodeoPilot ) )
		return true

	return false
}

void function Rodeo_SetBatterySkinRandom( bool random )
{
	file.shouldRandomBattery = random
}

bool function IsBatteryNowRandom()
{
	return file.shouldRandomBattery
}

void function Rodeo_SetBatteryIconsHide( bool hide )
{
	file.alwaysHideBatteryIcons = hide
}

void function Rodeo_SetWorldBatteryMaxCount( int count )
{
	file.worldBatteryMaxCount = count
}

void function Rodeo_SetBatteryPickupAllowed( bool allow )
{
	file.batteryPickUp = allow
}


#if DEV
void function SetDebugRodeoPrint( bool value )
{
	file.debugRodeoPrint = value
}

bool function GetDebugRodeoPrint()
{
	return file.debugRodeoPrint
}
#endif

#if MP
void function SetApplyBatteryCallback( void functionref(entity,entity,entity) func )
{
	file.applyBatteryCallback = func
}

bool function PlayerWantsToThrowNukeGrenade( entity player )
{
	return ( player in file.playersThatWantToUseRodeoGrenade )
}

bool function HasSuperRodeoGrenade( entity player )
{
	// HACK: because we ran out of player global net ints for "numSuperRodeoGrenades" in bounty hunt
	if ( GameRules_GetGameMode() != FD )
		return false
	return player.GetPlayerNetInt( "numSuperRodeoGrenades" ) > 0
}

void function DeductSuperRodeoGrenade( entity player, int amount )
{
	int num = player.GetPlayerNetInt( "numSuperRodeoGrenades" )
	player.SetPlayerNetInt( "numSuperRodeoGrenades", num-amount )
}

void function RodeoForceNuke( entity pilot )
{
	entity titan = GetTitanBeingRodeoed( pilot )
	if ( !IsValid( titan ) )
		return

	if ( !titan.IsNPC() || titan.GetTitanSoul().IsEjecting() )
		return

	table damageTable =
	{
		scriptType = damageTypes.rodeoBatteryRemoval
		forceKill = false
		damageSourceId = eDamageSourceId.core_overload
		origin = titan.GetOrigin()
		hitbox = 2
	}
	titan.TakeDamage( 1, pilot, pilot, damageTable )

	if ( !IsAlive( titan ) || titan.GetTitanSoul().IsEjecting() )
		return

	DeductSuperRodeoGrenade( pilot, 1 )

	// THROW RODEO RIDER OFF
	entity soul = titan.GetTitanSoul()
	soul.soul.nukeAttacker = pilot
	NPC_SetNuclearPayload( titan )

	vector ejectAngles = titan.GetAngles()
	ejectAngles.x = 270
	vector riderEjectAngles = AnglesCompose( ejectAngles, < 5, 0, 0 > )

	float speed = RandomFloatRange( 1900, 2100 )
	float gravityScale = expect float ( pilot.GetPlayerSettingsField( "gravityscale" ) )
	vector riderVelocity = AnglesToForward( riderEjectAngles ) * (speed * gravityScale) * 0.95
	ThrowRiderOff( pilot, titan, riderVelocity )

	if ( titan.ContextAction_IsBusy() )
		titan.ContextAction_ClearBusy()
	thread TitanEjectPlayer( titan, true )
}

void function OpenRodeoNukeWindow( entity player, entity titan )
{
	player.EndSignal( "RodeoNukeWindowEnded" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "RodeoOver" )
	titan.EndSignal( "OnDeath" )

	if ( player in file.playersThatWantToUseRodeoGrenade )
		delete file.playersThatWantToUseRodeoGrenade[ player ]

	if ( player.GetTeam() == titan.GetTeam() )
		return

	if ( !HasSuperRodeoGrenade( player ) )
		return

	Remote_CallFunction_NonReplay( player, "ServerCallback_NukeGrenadeWindowOpen" )

	OnThreadEnd(
	function() : ( player )
		{
			if ( IsValid( player ) )
				Remote_CallFunction_NonReplay( player, "ServerCallback_NukeGrenadeWindowClosed" )
		}
	)

	player.WaitSignal( "TryNukeGrenade" )

	if ( !HasSuperRodeoGrenade( player ) )
		return

	file.playersThatWantToUseRodeoGrenade[ player ] <- true

	MessageToPlayer( player, eEventNotifications.FD_SuperRodeoUsed )
	Rodeo_MoveBatteryDown( titan.GetTitanSoul() )
}

bool function ClientCommand_TryNukeGrenade( entity player, array<string> args )
{
	if ( HasSuperRodeoGrenade( player ) )
		player.Signal( "TryNukeGrenade" )

	return true
}
#endif

///// CLASSIC RODEO UTILITY START /////
const float CLASSIC_RODEO_SEQUENCE_START_DELAY = 0.5
const float CLASSIC_RODEO_SEQUENCE_INTERVAL = 0.5 // interval between each sequences
const float CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER = 0.2 // stryder protection

void function ClassicRodeoThink( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	if( !IsAlive( rodeoPilot ) ) // we did a waitthread before so here should have IsValid() check
		return
	if( !IsValid( titanSoul ) )
		return
	rodeoPilot.EndSignal( "OnDeath" )
	rodeoPilot.EndSignal( "OnDestroy" )
	rodeoPilot.EndSignal( "RodeoOver" )
	titanSoul.EndSignal( "OnDestroy" )
	rodeoPilot.Signal( "ClassicRodeoThink" )
	rodeoPilot.EndSignal( "ClassicRodeoThink" )

	entity rodeoTitan = titanSoul.GetTitan()
	bool sameTeam = rodeoPilot.GetTeam() == rodeoTitan.GetTeam()
	string rodeoTitanType = rodeoPackage.rodeoTargetType

	// starter sequences:
	/*if( file.automaticallyDoRodeoSequence )
	{
		if( PlayerHasBattery( rodeoPilot ) )
			waitthread PlayerAppliesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )*/
		if( ClassicRodeo_ShouldRemoveBattery( titanSoul ) && !sameTeam )
		{
			ClassicRodeo_TryMoveBatteryUp( titanSoul, true ) // for sometimes player rip a friendly's battery. it's the earliest removal try

			waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage ) //This ends rodeo at the end of the sequence

			// since classic rodeo condition has been changed, this has no use.
			//waitthread ClassicRodeoBatteryRemovalThink( rodeoPilot, titanSoul, rodeoPackage )
			if( file.continouslyRemoveBattery )
				thread ClassicRodeo_PlayerContinouslyRemoveBatteries( rodeoPilot, titanSoul, rodeoPackage )

			// waitthread will mess wait up, so we wait manually
			/*wait CLASSIC_RODEO_SEQUENCE_INTERVAL // do a wait here, make ripping slower
			if( rodeoTitanType == "stryder" )
				wait CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER // stryders wait 0.2s more, or ripping their batteries will be too fast*/
		}
	//}

	rodeoPilot.s.batteryCountAllowedToApply = GetPlayerBatteryCount( rodeoPilot ) // the only condition that pilot able to apply batteries, don't let them rip-plug all day long!
	//RodeoBatteryRemoval_ShowBattery( rodeoPilot ) // hide battery, will be shown at the end of a battery removal rodeo

	//This is default R1 style rodeo, with the panel ripped and ready to be shot at
	ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, true )
	rodeoPilot.s.grabbingTitan = true // doing grab
	//ClassicRodeoPilotPullsOutWeapon( rodeoPilot, rodeoTitan, rodeoTitanType ), , already handle in ClassicRodeo_GrabTargetTitan()

	ClassicRodeo_DoHintsBaseOnRodeoConditions( rodeoPilot, titanSoul )
	//CreateClassicRodeoHintEntityForPlayer( rodeoPilot ) // not finished yet, setParented players won't show useHints on their client
	thread ClassicRodeo_SequenceThink( rodeoPilot, titanSoul, rodeoPackage ) // for player doing sequences

	while( true )
	{
		rodeoTitan = titanSoul.GetTitan()

		if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 && !sameTeam )
		{	// modified condition: titan's bossplayer applied a battery to their titan, friendly rider will try to remove if holding melee
			// remove new-applied battery!
			waitthread ClassicRodeo_TryRemoveNewAppliedBattery( rodeoPilot, titanSoul, rodeoPackage )
		}

		if( rodeoPilot.GetTitanSoulBeingRodeoed() == titanSoul ) // pilot still rodeoing
		{
			//print( "re-Creating weaponPoint!" )
			waitthread ClassicRodeo_WeakPointThink( rodeoPilot, titanSoul, rodeoPackage ) // re-create hitbox if victim titan has been transfered
		}
	}
}

void function ClassicRodeo_SequenceThink( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	// this isn't waitthread off so do this
	rodeoPilot.EndSignal( "OnDeath" )
	rodeoPilot.EndSignal( "OnDestroy" )
	rodeoPilot.EndSignal( "RodeoOver" )
	titanSoul.EndSignal( "OnDestroy" )
	rodeoPilot.Signal( "RodeoSequenceThink" )
	rodeoPilot.EndSignal( "RodeoSequenceThink" )

	ClassicRodeo_AddPlayerInputs( rodeoPilot )

	OnThreadEnd(
		function(): ( rodeoPilot )
		{
			if( IsValid( rodeoPilot ) )
				ClassicRodeo_RemovePlayerInputs( rodeoPilot )
		}
	)


	/*if( !PlayerHasBattery( rodeoPilot ) && rodeoPilot.GetTeam() == titanSoul.GetTeam() && ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 )
	{
		int sec = 60
		while( sec >= 0 )
		{
			if( PlayerHasBattery( rodeoPilot ) )
				break
			if( IsValid( rodeoPilot ) )
				SendHudMessage( rodeoPilot, "准备重新补给中... "+ float( sec ) / 10 +" s",  -1, -0.3, 0, 255, 0, 0, 0, 0.2, 0);
			sec -= 1
			if( sec == 0 )
				thread ClassicRodeo_FriendlyRodeoOnBatteryReadyTips( rodeoPilot, titanSoul )
			wait 0.1
		}
	}*/
	while( true )
	{
		//if( rodeoPilot.GetTeam() == titanSoul.GetTeam() && !PlayerHasBattery( rodeoPilot ) && ClassicRodeo_GetSoulBatteryCount( titanSoul ) < 1 )
		//	thread ClassicRodeo_FriendlyRodeoOnBatteryReadyTips( rodeoPilot, titanSoul )
		table result = rodeoPilot.WaitSignal( "RodeoDefensiveSequence", "RodeoOffensiveSequence" )

		bool didSequence = false
		entity rodeoTitan = titanSoul.GetTitan()
		string rodeoTitanType = rodeoPackage.rodeoTargetType
		bool sameTeam = rodeoPilot.GetTeam() == titanSoul.GetTeam()
		bool pilotHasBattery = PlayerHasBattery( rodeoPilot )
		bool titanHasBattery = ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1

		if( result.signal == "RodeoDefensiveSequence" )
		{
			if( pilotHasBattery && sameTeam )
			{
				waitthread ClassicRodeo_PlayerAppliesBatteryPackWhileOnBoard( rodeoPilot, titanSoul, rodeoPackage )

				/*int sec = 60
				while( sec >= 0 )
				{
					if( PlayerHasBattery( rodeoPilot ) )
						break
					if( IsValid( rodeoPilot ) )
						SendHudMessage( rodeoPilot, "重新补给冷却中... "+ float( sec ) / 10 +" s",  -1, -0.3, 0, 255, 0, 0, 0, 0.2, 0);
					sec -= 1
					if( sec == 0 )
						thread ClassicRodeo_FriendlyRodeoOnBatteryReadyTips( rodeoPilot, titanSoul )
					wait 0.1
				}*/
			}
			/*if( !pilotHasBattery && sameTeam && titanHasBattery )
			{
				waitthread ClassicRodeo_PlayerOffensiveSequenceWhileOnBoard( rodeoPilot, titanSoul, rodeoPackage, titanHasBattery )

				entity battery = GetBatteryOnBack( rodeoPilot )

				if ( battery == null ) // not ideal but at least the game won't crash
					continue

				waitthread ClassicRodeo_PlayerAppliesBatteryPackWhileOnBoard( rodeoPilot, titanSoul, rodeoPackage )

				int sec = 60
				while( sec >= 0 )
				{
					if( PlayerHasBattery( rodeoPilot ) )
						break
					if( IsValid( rodeoPilot ) )
						SendHudMessage( rodeoPilot, "重新补给冷却中... "+ float( sec ) / 10 +" s",  -1, -0.3, 0, 255, 0, 0, 0, 0.2, 0);
					sec -= 1
					if( sec == 0 )
						thread ClassicRodeo_FriendlyRodeoOnBatteryReadyTips( rodeoPilot, titanSoul )
					wait 0.1
				}
			}*/
		}
		else if( result.signal == "RodeoOffensiveSequence" )
		{
			if( !sameTeam )
				waitthread ClassicRodeo_PlayerOffensiveSequenceWhileOnBoard( rodeoPilot, titanSoul, rodeoPackage, titanHasBattery )
		}
	}
}

void function ClassicRodeo_FriendlyRodeoOnBatteryReadyTips( entity rodeoPilot, entity titanSoul )
{
	rodeoPilot.EndSignal( "OnDeath" )
	rodeoPilot.EndSignal( "OnDestroy" )
	rodeoPilot.EndSignal( "RodeoOver" )
	titanSoul.EndSignal( "OnDestroy" )
	rodeoPilot.EndSignal( "RodeoSequenceThink" )
	rodeoPilot.EndSignal( "RodeoDefensiveSequence" )

	while( true )
	{
		WaitFrame()
		if( IsValid( rodeoPilot ) )
		{
			entity battery = GetBatteryOnBack( rodeoPilot )
			if( battery != null )
				break
			if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 )
				SendHudMessage( rodeoPilot, "重新补给已就绪",  -1, -0.3, 0, 255, 0, 0, 0, 0.2, 0);
			else
				SendHudMessage( rodeoPilot, "泰坦无电池 无法重新补给",  -1, -0.3, 255, 0, 0, 0, 0, 0.2, 0);
		}
	}
}


void function ClassicRodeo_WeakPointThink( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	//print( "startring WeakPointThink()!" )
	// this function is waitthreaded from others, no need to do these?
	//titanSoul.EndSignal( "OnDestroy" )
	//rodeoPilot.EndSignal( "OnDeath" )
	//rodeoPilot.EndSignal( "OnDestroy" )

	rodeoPilot.Signal( "RodeoWeakPointThink" )
	rodeoPilot.EndSignal( "RodeoWeakPointThink" )
	entity rodeoTitan = titanSoul.GetTitan()
	// signals for titan transfering
	rodeoTitan.EndSignal( "OnDestroy" )
	if( rodeoTitan.IsPlayer() )
	{
		rodeoTitan.EndSignal( "DisembarkingTitan" ) // for re-creating a weak point
		rodeoTitan.EndSignal( "ApplyBatteryToTitan" ) // modified condition, player applied a new battery to their titan
	}

	entity weakpointHitbox = CreateClassicRodeoWeakpoint( rodeoPilot, rodeoTitan )
	weakpointHitbox.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function() : ( weakpointHitbox, rodeoPilot, titanSoul )
		{
			if ( IsValid( weakpointHitbox ) )
				weakpointHitbox.Destroy()
		} )

	string rodeoTitanType = rodeoPackage.rodeoTargetType
	//if( rodeoTitanType == "stryder" ) // maybe don't need
	//	wait 0.2 // wait for stryders recover from fast animations?

	while ( true )
	{
		WaitFrame() // do one WaitFrame() at the start to avoid influencing animations

		if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 ) // titan still have battery left! maybe they applied one through embark
			weakpointHitbox.NotSolid() // not able to attack weakPoint till remove the battery
		else // battery has been removed
			weakpointHitbox.Solid()
	}
}

void function ClassicRodeo_TryRemoveNewAppliedBattery( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	//rodeoPilot.EndSignal( "PlayerRemovesBatteryPack" ) // fixed: well, no need. // god this have to add signals!!!
	//ClassicRodeo_TryMoveBatteryUp( titanSoul ) // moveUp function, has been handle in Rodeo_ApplyBatteryToTitan()
	//string titanType = GetSoulTitanSubClass( titanSoul )
	//titanSoul.soul.batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) ) // play battery regen animation
	wait CLASSIC_RODEO_SEQUENCE_START_DELAY // wait till panel animation done
	entity rodeoTitan = titanSoul.GetTitan()
	thread ManagePlayerWeaponDeployment( rodeoPilot, titanSoul )
	waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )
	//rodeoPilot.Anim_Stop() // clean up fp proxy, now done in ClassicRodeo_GrabTargetTitan()
	//rodeoPilot.Signal( "FriendlyRodeoDeployWeapon" ) // re-deploy weapon, already handle in ClassicRodeo_GrabTargetTitan()
	//WaitFrame() // for sequence completely ends
	if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) == 0 )
	{ // no battery left
		ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false ) // grab titan again
		//ClassicRodeoViewCone( rodeoPilot ) // restore viewcone, already handle in ClassicRodeo_GrabTargetTitan()
	}
	else if( file.continouslyRemoveBattery ) // still got batteries left! can stay on titan and remove rest of them
	{
		// preparation for removing, same as things done after removal
		ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false )
		ClassicRodeo_TryMoveBatteryUp( titanSoul )
		wait CLASSIC_RODEO_SEQUENCE_INTERVAL
		if( rodeoPackage.rodeoTargetType == "stryder" )
			wait CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER

		if( file.automaticallyDoRodeoSequence ) // remove rest batteries
			waitthread ClassicRodeo_PlayerContinouslyRemoveBatteries( rodeoPilot, titanSoul, rodeoPackage ) // this will wait 0.5s
	}
	else // still got batteries left! kick rider off
	{
		ThrowRiderOff( rodeoPilot, rodeoTitan, CalculateDirectionToThrowOffBatteryThief( rodeoPilot, rodeoTitan ) ) //This signals RodeoOver
	}
	//rodeoPilot.Signal( "RodeoOver" ) // kick off player
	//return thread ClassicRodeoThink( rodeoPilot, titanSoul, rodeoPackage ) // should restart it over
}

// waitthread will mess this up
void function ClassicRodeo_PlayerContinouslyRemoveBatteries( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	entity rodeoTitan = titanSoul.GetTitan()
	string rodeoTitanType = rodeoPackage.rodeoTargetType
	while( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 ) // keep ripping batteries!!!
	{
		rodeoTitan = titanSoul.GetTitan() // get current titan for player disembark conditions
		waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage ) //This ends rodeo at the end of the sequence
		ClassicRodeo_TryMoveBatteryUp( titanSoul ) // if titan still have battery left after removal, move it up
		//if( rodeoPilot.IsInputCommandHeld( IN_JUMP ) ) // player wants to jump off, no need now
		//	return
		//rodeoPilot.Anim_Stop() // may not necessary, put it here, , now done in ClassicRodeo_GrabTargetTitan()
		ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false ) // re-grab to have better animation?
		wait CLASSIC_RODEO_SEQUENCE_INTERVAL // do a wait here, make ripping slower
		if( rodeoTitanType == "stryder" )
			wait CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER // stryders wait 0.2s more, or ripping their batteries will be too fast
	}
}

/* // since classic rodeo condition has been changed, this has no use.
void function ClassicRodeoBatteryRemovalThink( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	// maybe don't need, since this is waitthreaded from other functions that has EndSignal()s, haven't tested whether this kind of thread will
	//rodeoPilot.EndSignal( "OnDeath" )
	//rodeoPilot.EndSignal( "OnDestroy" )
	//rodeoPilot.EndSignal( "RodeoOver" )
	//titanSoul.EndSignal( "OnDestroy" )

	//rodeoPilot.Anim_Stop() // may not necessary, put it here, , now done in ClassicRodeo_GrabTargetTitan()
	ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false )
	//rodeoPilot.Signal( "FriendlyRodeoDeployWeapon" ) // re-deploy weapon
	ClassicRodeo_TryMoveBatteryUp( titanSoul ) // if titan still have battery left after removal, move it up
	wait CLASSIC_RODEO_SEQUENCE_START_DELAY // wait for titans recover from fast animations? or it will loop removal animations and never deal damage

	entity rodeoTitan = titanSoul.GetTitan()
	string rodeoTitanType = rodeoPackage.rodeoTargetType

	if( file.continouslyRemoveBattery )
	{
		// waitthread will mess this up
		//waitthread ClassicRodeo_PlayerContinouslyRemoveBatteries( rodeoPilot, titanSoul, rodeoPackage )

		while( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 ) // keep ripping batteries!!!
		{
			rodeoTitan = titanSoul.GetTitan() // get current titan for player disembark conditions
			waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage ) //This ends rodeo at the end of the sequence
			ClassicRodeo_TryMoveBatteryUp( titanSoul ) // if titan still have battery left after removal, move it up
			ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false ) // re-grab to have better animation?
			wait CLASSIC_RODEO_SEQUENCE_INTERVAL // do a wait here, make ripping slower
			if( rodeoTitanType == "stryder" )
				wait CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER // stryders wait 0.2s more, or ripping their batteries will be too fast
		}
	}
}
*/

// NOPE, STILL MESSED UP
// waitthread messes these things up, ViewConeZeroInstant() may fix some of them?
void function ClassicRodeo_PlayerOffensiveSequenceWhileOnBoard( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage, bool isBatteryRemoval )
{
	entity rodeoTitan = titanSoul.GetTitan()
	string rodeoTitanType = rodeoPackage.rodeoTargetType

	thread ManagePlayerWeaponDeployment( rodeoPilot, titanSoul ) //Spin this off in its own thread since there are multiple ways for weapon to be deployed

	if( isBatteryRemoval )
		waitthread PlayerRemovesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )
	else
		waitthread PlayerThrowsGrenadeInHatch( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )

	if( file.continouslyRemoveBattery ) // player can stay on titans after throwing a grenade
	{
		ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false ) // grab titan again
		wait CLASSIC_RODEO_SEQUENCE_INTERVAL // always wait, to make throwing slower and recover from animations
		if( rodeoTitanType == "stryder" )
			wait CLASSIC_RODEO_SEQUENCE_ADDITIONAL_INTERVAL_STRYDER // don't make stryder dying so fast
	}
	else // throw player off
	{
		rodeoPilot.Signal( "RodeoOver" ) // not doing a ThrowRiderOff() since player is not jumping, will mess things up
	}
}

void function ClassicRodeo_PlayerAppliesBatteryPackWhileOnBoard( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage )
{
	entity rodeoTitan = titanSoul.GetTitan()
	string rodeoTitanType = rodeoPackage.rodeoTargetType

	ClassicRodeo_TryMoveBatteryDown( titanSoul ) // for better visual
	thread ManagePlayerWeaponDeployment( rodeoPilot, titanSoul ) //Spin this off in its own thread since there are multiple ways for weapon to be deployed
	waitthread PlayerAppliesBatteryPack( rodeoPilot, rodeoTitan, titanSoul, rodeoPackage )

	rodeoPilot.s.batteryCountAllowedToApply -= 1
	ClassicRodeo_GrabTargetTitan( rodeoPilot, titanSoul, rodeoPackage, false ) // grab titan again
}

void function ClassicRodeo_GrabTargetTitan( entity rodeoPilot, entity titanSoul, RodeoPackageStruct rodeoPackage, bool isClimbing )
{
	entity rodeoTitan = titanSoul.GetTitan()
	string rodeoTitanType = rodeoPackage.rodeoTargetType
	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	sequence.thirdPersonAnimIdle 	= GetAnimFromAlias( rodeoTitanType, "pt_rodeo_back_right_idle" )
	sequence.firstPersonAnimIdle 		= GetAnimFromAlias( rodeoTitanType, "ptpov_rodeo_back_right_idle" )
	sequence.useAnimatedRefAttachment  = true
	rodeoPilot.Anim_Stop() // clean up current animations!
	//rodeoPilot.GetFirstPersonProxy().HideFirstPersonProxy() // maybe use this instead of Anim_Stop()?
	thread FirstPersonSequence( sequence, rodeoPilot, rodeoTitan )

	ClassicRodeoViewCone( rodeoPilot )
	if( isClimbing )
		Rodeo_OnFinishClimbOnAnimation( rodeoPilot )
	rodeoPilot.Signal( "FriendlyRodeoDeployWeapon" )
}

/* // better be in ClassicRodeo_GrabTargetTitan()
void function ClassicRodeoPilotPullsOutWeapon( entity rodeoPilot, entity rodeoTitan, string rodeoTitanType )
{
	ClassicRodeoViewCone( rodeoPilot )

	Rodeo_OnFinishClimbOnAnimation( rodeoPilot ) // This is to let code know the rodeoPilot has finished climbing on the rodeo and ready to fire
	rodeoPilot.Signal( "FriendlyRodeoDeployWeapon" )
}
*/

void function ClassicRodeoViewCone( entity player )
{
	player.PlayerCone_FromAnim()
	player.GetFirstPersonProxy().HideFirstPersonProxy()
	OpenViewCone( player )
}

///// PLAYER CONTROLS /////
void function ClassicRodeo_DoHintsBaseOnRodeoConditions( entity player, entity titanSoul )
{
	bool sameTeam = titanSoul.GetTeam() == player.GetTeam()
	bool ableToApplyBattery = ClassicRodeo_GetBatteryCountPlayerAllowedToApply( player ) >= 1
	bool titanHasBattery = ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1
	bool playerHasBattery = PlayerHasBattery( player )

	string curHints = ""
	string puncToAdd
	if( sameTeam )//&& PlayerHasBattery( player ) ) // offensive hint
	{
		curHints = "輕按 使用鍵 (默認為\"E\") 給予電池"
	}
	/*else if ( sameTeam && !PlayerHasBattery( player ) && titanHasBattery )
	{
		curHints = "輕按 使用鍵 (默認為\"E\") 以重新補給"
	}
	else if ( sameTeam && !PlayerHasBattery( player ) && !titanHasBattery )
	{
		curHints = "oops..! 你和泰坦都沒有電池 去找一塊"
	}*/
	else if( !sameTeam )
	{
		curHints = "射擊電池倉以快速毀減敵方泰坦"
	}

	if( curHints == "" )
		return
	NSSendInfoMessageToPlayer( player, curHints )
}


void function ClassicRodeo_AllowForceEndRodeoLifeLong( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	while( player.GetParent() ) // player rodeoing!
	{
		if( player.IsInputCommandHeld( IN_JUMP ) ) // try to jump off
		{
			player.Signal( "RodeoOver" ) // no returning, just keep it if player having parent
			//print( "player wants to jump off!" )
		}
		//print( "waiting for classic rodeo rider jump off" )
		WaitFrame()
	}
}

///// CALLBACKS /////
void function ClassicRodeo_DropAllStoredBatteries( entity ent, var damageInfo )
{
	if( !ClassicRodeo_IsEnabled() )
		return
	if( !ent.IsTitan() )
		return
	entity titanSoul = ent.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return

	int batteryCount = ClassicRodeo_GetSoulBatteryCount( titanSoul ) // Floats instead of ints since we need decimal values for the math
	if( batteryCount < 1 )
		return
	for ( int i = 1; i <= batteryCount; i += 1 )
	{
		entity newBattery = Rodeo_CreateBatteryPack()
		newBattery.s.touchEnabledTime = Time() + 0.3
		vector direction = AnglesToForward( < 0, float( i ) / float( batteryCount ) * 360.0, 0 > )
		newBattery.SetOrigin( ent.GetWorldSpaceCenter() + direction * 30 )
		newBattery.SetAngles( <0, 0, 0 > )
		vector baseVelocity = ent.GetVelocity()
		baseVelocity.z = 0
		newBattery.SetVelocity( baseVelocity + direction * 100 + <0, 0, 1> )

		int random = RandomInt( 10 )
		if( random <= 8 )	//0,1,2,3,4,5,6,7,8 -> 90%Yellow 10%Green
		{
			newBattery.SetSkin( 2 )
		}
		Battery_StartFX( newBattery )
	}
}

void function ClassicRodeo_UpdateBatteryContainer( entity player, entity titan )
{
	if( !ClassicRodeo_IsEnabled() )
		return

	// first update
	entity titanSoul
	if( player.IsTitan() )
		titanSoul = player.GetTitanSoul()
	else
		titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return

	bool hasBatteryBeforeApplying = false
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity rodeoPanel = titanSoul.soul.batteryContainer
	entity rider = GetRodeoPilot( titanSoul.GetTitan() ) // ClassicRodeo_GetSoulRodeoRider( titanSoul )
	if( IsValid( rider ) ) // has rider?
	{
		if( ClassicRodeo_IsPlayerRemovingBatteryPack( rider ) ) // rider is ripping battery, don't update
			return
	}
	if( !IsValid( rodeoPanel ) )
		return
	if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) < 1 )
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down_idle" ) )
	else
	{
		hasBatteryBeforeApplying = true
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up_idle" ) )
	}

	thread UpdateBatteryContainerForEmbark( player, titan, hasBatteryBeforeApplying )
}

void function UpdateBatteryContainerForEmbark( entity player, entity titan, bool hasBatteryBeforeApplying )
{
	// following update for sometimes player applying batteries when embarks
	entity titanSoul
	if( player.IsTitan() )
		titanSoul = player.GetTitanSoul()
	else
		titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return
	titanSoul.EndSignal( "OnDestroy" )

	wait 0.5 // wait a bit more than Rodeo_ApplyAllBatteriesOnEmbark()
	entity rider = GetRodeoPilot( titanSoul.GetTitan() )
	if( IsValid( rider ) ) // has rider?
	{
		if( ClassicRodeo_IsPlayerRemovingBatteryPack( rider ) ) // animations will be handle by ClassicRodeo_TryRemoveNewAppliedBattery()
			return
	}
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity rodeoPanel = titanSoul.soul.batteryContainer
	if( !IsValid( rodeoPanel ) )
		return
	if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) < 1 )
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down_idle" ) )
	else if( !hasBatteryBeforeApplying )
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
}

///// SETTINGS( entity.s ) UTILITY /////
void function ClassicRodeo_InitPlayerSettings( entity player )
{
	player.s.grabbingTitan <- false
	player.s.applyingBatteryPack <- false
	player.s.removingBatteryPack <- false
	player.s.throwingGrenadeInHatch <- false
	player.s.batteryCountAllowedToApply <- 0
}

void function ClassicRodeo_SettingsCleanUp( entity player )
{
	player.s.grabbingTitan = false
	player.s.applyingBatteryPack = false
	player.s.removingBatteryPack = false
	player.s.throwingGrenadeInHatch = false
	player.s.batteryCountAllowedToApply = 0
}

void function ClassicRodeo_InitTitanSettings( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // mostly appears when disembark, it's good for we only need init once
		return

	if( "classicRodeoInited" in titanSoul.s ) // has Inited! don't reset it
		return

	titanSoul.s.classicRodeoBatteryCount <- file.classicRodeoStarterBatteryCount
	titanSoul.s.classicRodeoInited <- true

	// don't know whether to use
	//thread ClassicRodeo_WaitForBatteryPanelValidThenInit( titanSoul )
}

void function ClassicRodeo_AddPlayerInputs( entity player )
{
	AddButtonPressedPlayerInputCallback( player, IN_USE, ClassicRodeo_TrySignalDefensiveSequence )
	AddButtonPressedPlayerInputCallback( player, IN_MELEE, ClassicRodeo_TrySignalOffensiveSequence )
}

void function ClassicRodeo_RemovePlayerInputs( entity player )
{
	RemoveButtonPressedPlayerInputCallback( player, IN_USE, ClassicRodeo_TrySignalDefensiveSequence )
	RemoveButtonPressedPlayerInputCallback( player, IN_MELEE, ClassicRodeo_TrySignalOffensiveSequence )
}

void function ClassicRodeo_TrySignalDefensiveSequence( entity player )
{
	if( !IsValid( player.GetTitanSoulBeingRodeoed() ) )
		return

	player.Signal( "RodeoDefensiveSequence" )
}

void function ClassicRodeo_TrySignalOffensiveSequence( entity player )
{
	if( !IsValid( player.GetTitanSoulBeingRodeoed() ) )
		return

	//player.Signal( "RodeoOffensiveSequence" )
}

/* unused
void function ClassicRodeo_WaitForBatteryPanelValidThenInit( entity titanSoul )
{
	titanSoul.EndSignal( "OnDestroy" )
	while( !IsValid( titanSoul.soul.batteryContainer ) ) // wait for this being created
		WaitFrame()

	titanSoul.soul.batteryContainer.panelMoveUpBattery <- false
	titanSoul.soul.batteryContainer.panelMoveDownBattery <- false
}
*/

///// BATTERY UTILITY /////
void function ClassicRodeo_AddSoulBattery( entity titanSoul )
{
	if( !IsValid( titanSoul ) )
		return

	printt("soulBatteryCount is added")
	titanSoul.s.classicRodeoBatteryCount <- 1
}

void function ClassicRodeo_RemoveSoulBattery( entity titanSoul )
{
	if( !IsValid( titanSoul ) )
		return

	if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) >= 1 )
		titanSoul.s.classicRodeoBatteryCount = 0
}

int function ClassicRodeo_GetSoulBatteryCount( entity titanSoul )
{
	if( !IsValid( titanSoul ) )
		return 0

	return expect int( titanSoul.s.classicRodeoBatteryCount )
}

void function ClassicRodeo_SetSoulBatteryCount( entity titanSoul, int count )
{
	if( !IsValid( titanSoul ) )
		return

	if( count < 0 )
		count = 0

	titanSoul.s.classicRodeoBatteryCount = count
}

bool function ClassicRodeo_ShouldRemoveBattery( entity titanSoul )
{
	int batteryCount = expect int( titanSoul.s.classicRodeoBatteryCount )
	if( batteryCount < 1 )
		return false

	return true
}

///// RODEO RIDERS UTILITY /////
/* // respawn has GetRodeoPilot() so no need to use this
entity function ClassicRodeo_GetSoulRodeoRider( entity titanSoul ) // can return entity or null
{
	foreach( entity player in GetPlayerArray() )
	{
		if( player.GetTitanSoulBeingRodeoed() == titanSoul )
			return player
	}
	return null
}
*/

bool function ClassicRodeo_IsPlayerGrabbingTitan( entity player )
{
	if( !IsAlive( player ) )
		return false

	return expect bool( player.s.grabbingTitan )
}

bool function ClassicRodeo_IsPlayerApplyingBatteryPack( entity player )
{
	if( !IsAlive( player ) )
		return false

	return expect bool( player.s.applyingBatteryPack )
}

bool function ClassicRodeo_IsPlayerRemovingBatteryPack( entity player )
{
	if( !IsAlive( player ) )
		return false

	return expect bool( player.s.removingBatteryPack )
}

bool function ClassicRodeo_IsPlayerThrowingGrenadeInHatch( entity player )
{
	if( !IsAlive( player ) )
		return false

	return expect bool( player.s.throwingGrenadeInHatch )
}

int function ClassicRodeo_GetBatteryCountPlayerAllowedToApply( entity player )
{
	if( !IsAlive( player ) )
		return 0

	return expect int( player.s.batteryCountAllowedToApply )
}

///// BATTERY CONTAINER STATE /////
bool function ClassicRodeo_ShouldMoveUpBattery( entity titanSoul )
{
	if( !IsValid( titanSoul ) )
		return false
	//if( !titanSoul.soul.batteryMovedDown )
	//	return false

	if( ClassicRodeo_GetSoulBatteryCount( titanSoul ) < 1 )
		return false
	return true
}

void function ClassicRodeo_TryMoveBatteryUp( entity soul, bool isClimbingRemoval = false )
{
	if( !soul.soul.batteryMovedDown && isClimbingRemoval ) // since theres no other function controlling "batteryMovedDown", should only check this if try to do removal right after climing.
		return
	if( !ClassicRodeo_IsEnabled() || !ClassicRodeo_ShouldMoveUpBattery( soul ) )
		return

	string titanType = GetSoulTitanSubClass( soul )
	entity batteryContainer = soul.soul.batteryContainer
	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
	soul.soul.batteryMovedDown = false
}

void function ClassicRodeo_TryMoveBatteryDown( entity soul, bool isClimbingRemoval = false )
{
	if( ClassicRodeo_GetSoulBatteryCount( soul ) < 1 ) // no enough battery
		return
	if( soul.soul.batteryMovedDown && isClimbingRemoval ) // since theres no other function controlling "batteryMovedDown", should only check this if try to do removal right after climing.
		return
	if( !ClassicRodeo_IsEnabled() || !ClassicRodeo_ShouldMoveUpBattery( soul ) )
		return

	string titanType = GetSoulTitanSubClass( soul )
	entity batteryContainer = soul.soul.batteryContainer
	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down" ) )
	soul.soul.batteryMovedDown = true
}

/* // unused
void function ClassicRodeo_SetRodeoPanelMoveUpBattery( entity titanSoul, bool move )
{
	if( !IsValid( titanSoul ) )
		return
	entity rodeoPanel = titanSoul.soul.batteryContainer
	if( !( "panelMoveUpBattery" in rodeoPanel.s ) )
		rodeoPanel.s.panelMoveUpBattery <- false

	rodeoPanel.s.panelMoveUpBattery = move
	if( move )
	{
		string titanType = GetSoulTitanSubClass( titanSoul )
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up" ) )
	}
}

void function ClassicRodeo_SetRodeoPanelMoveDownBattery( entity titanSoul, bool move )
{
	if( !IsValid( titanSoul ) )
		return
	entity rodeoPanel = titanSoul.soul.batteryContainer
	if( !( "panelMoveDownBattery" in rodeoPanel.s ) )
		rodeoPanel.s.panelMoveDownBattery <- false

	rodeoPanel.s.panelMoveDownBattery = move
	if( move )
	{
		string titanType = GetSoulTitanSubClass( titanSoul )
		rodeoPanel.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down" ) )
	}
}
*/

///// MODE CONFRIMATION UTILITY /////
void function ClassicRodeo_SetEnabled( bool enabled )
{
	file.classicRodeoEnabled = enabled
}

bool function ClassicRodeo_IsEnabled()
{
	return file.classicRodeoEnabled
}

void function ClassicRodeo_SetStarterBatteryCount( int count )
{
	if( count <= 0 ) // at least start with 1 battery
		count = 1
	file.classicRodeoStarterBatteryCount = count
}

void function ClassicRodeo_AllowContinouslyRemoveBattery( bool allow )
{
	file.continouslyRemoveBattery = allow
}

void function ClassicRodeo_SetBatteryRemovalDamageAmped( bool amp )
{
	file.batteryRemovalDamageAmped = amp
}

void function ClassicRodeo_BatteryContainerOnlyProtectsOnce( bool once )
{
	file.batteryContainerOnlyProtectsOnce = once
}

/*void function ClassicRodeo_OwnerApplyBatteryAllowed( bool allowed )
{
	file.ownerApplyBatteryAllowed = allowed
}*/

void function ClassicRodeo_SetShouldAutomaticallyDoRodeoSequence( bool should )
{
	file.automaticallyDoRodeoSequence = should
}
///////////////////////////////////////
///// CLASSIC RODEO FUNCTIONS END /////
///////////////////////////////////////

//////////////////////////////
///// MODIFIED UTILITIES /////
//////////////////////////////